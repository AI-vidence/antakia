{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-antakia","title":"Welcome to AntakIA !","text":"<p>AntakIA is a software allowing you mainly to explore a trained machine learning (ML) model and discover what it has understood from the training data. A key issue for data scientist is to explain (one speaks of explainability of AI, aka X-AI) the model to have it adopted, and also in a short time certified to be compliant with the law. As a matter of fact, Europe has issue its AI act by the beginning of 2024. This text requires companies, when they use AI for certain use cases (high risk), to have their model certified, or sometimes self-certified.</p> <p>AntakIA is a solution for this compliance issue. But it does more. For instancee it allows data scientist:</p> <ul> <li>to themselves better understand their dataset and model,</li> <li>help marketing teams to get new insights on their customers,</li> <li>help compliance officers to better understand the limits of the model,</li> <li>etc.</li> </ul> <p>Here is a quick tour of AntakIA: </p> <p>See full video on Youtube</p> <p>AntakIA is an open-source project by AI-vidence, a French start-up commited on trustworthy AI. It showcases their regional approach for AI explainability.</p> <ol> <li>Besides local and global explainability, we believe in a more relevant and intermediate scale to observe phenomena. Through a dyadic approach, it is then possible to divide accordingly the multidimensional space of input values in regions, sub-spaces where both the observations, and their explanations are alike.</li> <li>Bonus : data scientists can consequently try and substitute the original black box model with simpler and explainable models on each region.</li> </ol> <p>Because we split the space in smaller pieces, with simpler surrogate models on each piece, we named our approach from the antique city Antakia (in T\u00fcrkiye nowadays) famous for its roman mosaics. By the way, it also stands for A New Tool to Acquire Knowledge from artificIAl intelligence, and that what've been working on for a while !</p> <p>Now, you're only a <code>pip install antakia</code> away from AntakIA  :) ... See our getting started page for detailed instructions</p>"},{"location":"#contents","title":"Contents","text":"<p>Below is what you'll find in this documentation :</p> <ul> <li>Getting started : install and usage</li> <li>Tutorials : step by step guides to run AntakIA on some datasets</li> <li>Regional explainability and the science behind it</li> <li>About AI-vidence, the team behind AntakIA</li> <li>Credits</li> </ul>"},{"location":"#logs","title":"Logs","text":"<p><code>antakia</code> is our open-source project. We plan to learn a lot from it to build our SaaS product, and earn our living. By default, <code>antakia</code> sends anonymous usage logs to our server. With this data, we cannot discover who you are, what you do, or what data you work on. It only tells us how people use the software. However, if you don't want us to receive this data, just create a <code>.env</code> file at the root of your project folder with the following line <code>SEND_ANONYMOUS_LOGS=false</code></p>"},{"location":"about/","title":"About us","text":"<p>Hi! AntakIA has been first released by AI-vidence a French start-up commited to AI explainabily and trusted AI in general.</p> <p>AntakIA is our open-source product. It adresses the need for transparence and understanding on how ML models work. Some companies will use it for compliance with the coming AI act. Others will use it to foster adoption of the model : internally or with clients. Also data scientists will benefit from AntakIA to better build models on their dataset.</p> <p>Besides AntakIA, AI-vidence proposes complete paid solutions for some industries. Please visit www.ai-vidence.com for mmore details.</p> <p>It was really important for us to release it open-source. All data scientists in the world heavily rely on open-souce tools : Python, Jupyter, Scikit-learn, Pandas, to name a few. We believe it is fair to release a complete and useful version of our product open-source.</p> <p>The AntakIA method was invented in 2021. Very soon, we got evidence (!) of interest for it. The ACPR, French regulatory for banks, awarded us for AntakIA in a explainability hackathon. The year after we joined Confiance.ai a French industrial collective funded by the French State.</p> <p>We're currently working with major corporates to explain their models and improve our product.</p>"},{"location":"credits/","title":"Credits","text":"<ul> <li>A great many thanks to the BourbakIA winning team (Jean-Matthieu Schertzer, C\u00e9dric Faucheux, Jean Cupe, Nicolas B\u00e9guin and David Cort\u00e9s) ! this methodology and prototype which has led to AntakIA is the direct following of that 2-day hackathon organised by the French financial regulator (ACPR). Special thanks to Jean-Matthieu, for his great work developping Skope-Rules...</li> <li>We are also very grateful to the Confiance.AI national French initiative, for helping us try this approach with great French industrial actors, to increase adoption and robustness of high risk models.</li> <li>We also try the calculation of Banzhaf indices (not only Shapley) more stable and less computer intensive following our ongoing discussion with the CRIL (Centre de Recherche en Informatique de Lens, Pierre Marquis, Gilles Audemard, Jean-Marie Lagniez, Steve Bellart, Louenas Bounia). Quite a lot more to come ! and do have a look at this quite promising initiative on X-AI by the CRIL</li> <li>Special thanks to the Jupyter project team. Without Jupyter, some particular AntakIA wouldn't be possible : ipywidgets or ipyvuetify from the great Widgetti team ...</li> <li>Thanks to SoyHuCe, Weituo Dai, Antoine Edy, Xavier Lekeuka for paving the way !</li> <li>Special thanks to the alpha and beta testers...</li> <li>And as many other French start-ups, thanks also to France2030, Mairie de Paris, Incubateur Telecom Paris to help get things started...</li> </ul>"},{"location":"getting_started/","title":"Installation","text":""},{"location":"getting_started/#install","title":"Install","text":"<p>AntakIA is available on PyPI :</p> <pre><code>pip install antakia\n</code></pre>"},{"location":"getting_started/#running-example-notebooks","title":"Running example notebooks","text":"<p>Once you've installed <code>antakia</code>, you can download some of our notebook examples from our repo here.</p> <p>Then, launch a Jupyter server from the notebook file (<code>.ipynb</code>) location :</p> <pre><code>jupyter notebook # or jupyter lab\n</code></pre> <p>At least you'll need <code>california_housing.ipynb</code>and <code>california_housing.csv</code> from our repo if you want to do our tutorial. </p> <p>Important</p> <p>If you're using a virtual env, it's handy to be able to chose it from Jupyter's kernel list. Do the following :</p> <pre><code>python -m ipykernel install --user --name your_venv_name --display-name \"My great virtual env\"\n</code></pre>"},{"location":"getting_started/#online-demo","title":"Online demo","text":"<p>You can give <code>antakia</code> a try online  : https://demo.antakia.ai </p> <p>Log as <code>demo</code>  with password <code>antakia</code>. Note it runs on a simple server and may be busy. You may want to log with other accounts : <code>demo1</code> to <code>demo5</code> are accepted with the same password.</p>"},{"location":"getting_started/#run-with-docker","title":"Run with Docker","text":"<p>Important</p> <p>Be sure to have a Docker engine running on your computer (ie. launch Docker Desktop)</p> <pre><code>docker build -t antakia .\ndocker run -p 8888:8888 antakia\n</code></pre> <p>In your Terminal, click on the <code>http://127.0.0.1:8888/lab?token=WHATEVER_YOUR_TOKEN_IS URL</code> link.</p>"},{"location":"regional_explain/","title":"Regional explaination for trustworthy AI by design","text":""},{"location":"regional_explain/#context","title":"Context","text":"<p>Most business needs and most famous ML algorithms themselves rely on \u2018segmentation\u2019. Classical ML model explaination tools like SHAP, LIME, do address the local (decision level) or global scales (model level), but none of them approach the \u2018regional\u2019 scale (segment). Understanding by both the data scientist (DS) and business owner (BO) often relies on that specific scale (be it Operation Regime, Customer segment) still not dealt with.</p>"},{"location":"regional_explain/#keywords","title":"Keywords","text":"<p>Regional explaination , segmentation, clustering, SHAP, LIME, decision trees, data visualisation, Banzhaf , Shapley Shubick , TreeRank , ranking forest</p>"},{"location":"regional_explain/#our-dyadic-approach","title":"Our dyadic approach","text":"<p>AntakIA methodology by AI-vidence aims at gaining a common understanding between the DS (data scientist) and firstly the BO (Business Owner) by building explainations of the models at a regional level. The main steps leading to Regional Explaination rely on \u2018dyadic\u2019 steps, implying simultaneously the Values Space (VS) and Explainations Space (ES) computed e.g. through Shapley values or other indexes. The ES is constructed by computing a local explanation for each data point of the data set. Quite a lot of explanation values can be used, depending on the goal and the situation. For example, LIME values can be more understandable when the phenomenom is rather linear. Shapley values have become a standard, and give and additive approach of the estimated importance of each predictor to account for the gap between the prediction and the mean. Correlations with other predictors can be a way to constitute such a space when the dataset is a set of windowed time series, for instance, etc.</p>"},{"location":"regional_explain/#dyadic-visualisation","title":"Dyadic visualisation","text":"<p>Visualize the VS and ES datasets at the same time through dimensions reduction approaches (e.g. PCA, t-SNE, UMAP, PACMAP,...) Especially xMAP approaches help at getting a sense of how close observations (in the VS) and explanations (in the ES) are. At this point, some obvious clusters can visually appear in both spaces.</p>"},{"location":"regional_explain/#dyadic-exploration","title":"Dyadic exploration","text":"<p>Explore the simultaneously consistent zones of both spaces with DS and BO. Through manual selection of points, the DS or BO suggests to explore the dataset, starting either in the VS (classical clustering) or in the ES (explainations clustering : points close in the ES share similar explanations). Here, we aim at identifying the first regions, namely selection of points clustering simultaneously in the ES and the VS Some ML tools are useful at that step :</p> <ul> <li>data visualisation</li> <li>Skope Rules, to provide the simplest description of a selection of points through rules on values of predictors. The result mainly helps to understand the model behaviour when used in the ES. In the VS, those rules help get a first natural definition of a classical segment.</li> <li>DiCE, to exhibit an archetype of the segment, or a counterfactual (soon implemented !)</li> <li>causal inference and DAG (soon implemented !)</li> <li>...</li> </ul> <p>When one succeeds to identify such a doubly homogeneous selection, then a raw region is defined.</p>"},{"location":"regional_explain/#dyadic-segmentation","title":"Dyadic segmentation","text":"<p>Define precisely a region, describe as simply as possible each region in both spaces At this step, density graphs are used in both the VS and the ES to define precisely the segment, predictor-wise. For instance, the BO or the DS could consider sub-segmenting, given the distribution of the data points along the predictor(s) whole range of values. To remain esaily usable, the segment should be described through ranges of values in the VS.</p>"},{"location":"regional_explain/#dyadic-understanding","title":"Dyadic understanding","text":"<p>Make sure it makes sense ! Through mutual explaination and understanding between the DS and BO, with complementary feature wise analyses. This ultimate step is essential, not to have spurious selection of points. This paves the way for the next important step of the methodology towards and explainable by design Model : defining a surrogate explianable model on each region.</p> <p>These steps are to be iterated until all the VS is addressed.</p>"},{"location":"regional_explain/#result-on-toys-dataset","title":"Result on toys dataset","text":"<p>On a simple simulated datasets with an explicitly 5 segment biased model (e.g. age below 25, or over 40 and man vs woman , etc.), we have been able through this dyadic approach to reconstruct the relevant segments learnt by a standard black box Model ( XGBoost )), considering simultaneously the original values and model explainations.</p>"},{"location":"regional_explain/#result-on-anomaly-detection-use-case","title":"Result on anomaly detection use case","text":"<p>We have been using this dyadic approach for anomaly detection on time series - defining a more understandable VS (with signal procesing and ad hoc aggregated features) - using unsupervised detection anomaly algorithms then SHAP to construct an ES</p> <p>Do have a look to the ever evolving /demo folder for recent illustrative contributions.</p>"},{"location":"regional_explain/#prospects-and-future-work","title":"Prospects and future Work","text":"<p>AntakIA methodology also encompasses the building of surrogate models so as to construct Explainable , then hopefully Certifiable AI by design. We will be analysing the gain of using :</p> <ul> <li>other decision decision power indexes e.g. from games theory Banzhaf , Shapley Shubick , \u2026),</li> <li>other specific explainations methods e.g. tree based extracted from surrogate logical models [P. Marquis],</li> <li>top performance surrogate models generic or more specific, such as TreeRank algorithms for ranking [S. Clemen\u00e7on ].</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Our Github repository comes with several example notebooks.</p> <p>Below are some tutorials we propose to get familiar with AntakIA :</p> <ul> <li>California housing</li> <li>Wages</li> <li>Titanic</li> </ul>"},{"location":"examples/california1/","title":"California housing tutorial (1/2)","text":"<p>This is the part 1 of our tutorial. It explains how to prepare data and launch AntakIA. Those steps are common to most of AntakIA usages. If you feel familiar enough, you can directly jump to the second part.</p>"},{"location":"examples/california1/#the-california-housing-dataset","title":"The California housing dataset","text":"<p>We'll use the California housing dataset, very famous in the datascience ecosystem</p> <p>This dataset describes 20 640 block groups (ie. groups of houses) in California using 8 variables :</p> Variable Description MedInc median income in block group HouseAge median house age in block group AveRooms average number of rooms per household AveBedrms average number of bedrooms per household Population block group population AveOccup average number of household members Latitude block group latitude Longitude block group longitude <p>The dataset also gives for each block group the average price of a house. This data comes from real real estate transactions.</p> <p>In our noteboox, this dataset is stored in a Pandas Dataframe named <code>X</code>. If you type <code>X.head()</code> you'll get :</p> <p></p> <p>The \"medium house values\" are stored in a Pandas Series named <code>y</code>. A <code>y.head()</code> will give you something like :</p> <p></p>"},{"location":"examples/california1/#the-use-case","title":"The use case","text":"<p>We can imagine several use cases where AntakIA could be useful: * Let's say you're a real estate agent in California. A data scientist in your team has trained a wonderful ML model that is capable of predicting the market value of any house in the state, as long as you provide sufficent data. You're amazed and want to understand how this model works in order to gain insights of your market: what drives the price ? any segmentation ? So you decided to use AntakIA. * Or, you don't have such model. But you still want to have an accurate understanding of your market. Then you ask a data scientist to train a model. Add then you use AntakIA on it.</p> <p>It's quite the same story: you have a dataset <code>X</code>, you do a supervised training on (<code>X</code>,<code>y</code>) to get a fitted model M. AntakIA will help you to understand how and why M can predict house values.</p>"},{"location":"examples/california1/#preparing-the-data","title":"Preparing the data","text":"<p>Launch a Jupyter server and open the notebook <code>california_housing.ipynb</code> (see Getting started page).</p> <p>Let's analyze the first cells :</p> <pre><code>import pandas as pd\ndf = pd.read_csv('../data/california_housing.csv').drop(['Unnamed: 0'], axis=1)\n</code></pre> <p>We start creating a dataframe from a local CSV file. You could have imported this dataset from the Scikit-learn package here. As you'll see, AntakIA needs to compute other values (eg. SHAP values for the data and the model). So as to make this tutorial quicker and more pleaseant, our CSV file includes these pre-computed SHAP values.</p> <pre><code># Remove outliers:\ndf = df.loc[df['Population']&lt;10000] \ndf = df.loc[df['AveOccup']&lt;6]\ndf = df.loc[df['AveBedrms']&lt;1.5]\ndf = df.loc[df['HouseAge']&lt;50]\n\n# # Only San Francisco :\ndf = df.loc[(df['Latitude']&lt;38.07)&amp;(df['Latitude']&gt;37.2)]\ndf = df.loc[(df['Longitude']&gt;-122.5)&amp;(df['Longitude']&lt;-121.75)]\n</code></pre> <p>In the same way, the previous lines are not compulsory. But it appears that the dataset for the sole city of San Francisco is better to get rapidly a good intuition of how AntakIA works.</p> <pre><code>X = df.iloc[:,0:8] # the dataset\ny = df.iloc[:,9] # the target variable\nshap_values = df.iloc[:,[10,11,12,13,14,15,16,17]] # the SHAP values\n</code></pre> <p>Here we have extracted from our big CSV dataset : the <code>X</code> values, the <code>y</code> Series and the <code>shap_values</code> (we'll explain those values further).</p> <pre><code>from sklearn.ensemble import GradientBoostingRegressor\nmodel = GradientBoostingRegressor(random_state = 9)\nmodel.fit(X, y)\n</code></pre> <p>We decided to use a GradientBoosting model and have it trained (or fitted) on our data. Now our data is prepared and our model trained, we can then launch AntakIA :</p> <pre><code>from antakia.antakia import AntakIA\natk = AntakIA([X], y, model)\natk.start_gui()\n</code></pre> <p>It's that simple !</p> <p>Yet, in this tutorial we'll use another method to launch AntakIA :</p> <pre><code>from antakia.antakia import AntakIA\n\nvariables_df = pd.DataFrame(\n    {'col_index': [0, 1, 2, 3, 4, 5, 6, 7],\n    'descr': ['Median income', 'House age', 'Average nb rooms', 'Average nb bedrooms', 'Population', 'Average occupancy', 'Latitude', 'Longitude'],\n    'type': ['float64', 'int', 'float64', 'float64', 'int', 'float64', 'float64', 'float64'],\n    'unit': ['k$', 'years', 'rooms', 'rooms', 'people', 'ratio', 'degrees', 'degrees'],\n    'critical': [True, False, False, False, False, False, False, False],\n    'lat': [False, False, False, False, False, False, True, False],\n    'lon': [False, False, False, False, False, False, False, True]},\n    index=['MedInc', 'HouseAge', 'AveRooms', 'AveBedrms', 'Population', 'AveOccup', 'Latitude', 'Longitude']\n)\n\natk = AntakIA(X, y, model, variables_df, shap_values)\natk.start_gui()\n</code></pre> <p>Two differences with this method :</p> <ol> <li>we've passed to AntakIA a description of the dataset variables :</li> <li>description</li> <li>it critical ?</li> <li>do we have geographical data ?</li> <li>type of the variable</li> <li> <p>which unit is used ?</p> </li> <li> <p>we've also passed pre-computed SHAP values.</p> </li> </ol> <p>Now we're ready to discover AntakIA. You can go to the second part of our tutorial.</p>"},{"location":"examples/california2/","title":"California housing tutorial (2/2)","text":"<p>This is the part 2 of our tutorial. We'll dive into the actual use of AntakIA. If you have questions on the California housing dataset and how to start AntakIA, you should start with the first part of the tutorial.</p>"},{"location":"examples/california2/#the-antakia-ui","title":"The AntakIA UI","text":""},{"location":"examples/california2/#a-first-glimpse-of-antakia","title":"A first glimpse of AntakIA","text":"<p>Important</p> <p>The main idea of our AntakIA method is to divide the dataset <code>X</code> in several parts (we say \"regions\", hence the regional explainability) where we can substitute the inital complex trained model (often refered to as a black box) with simple and explainable models, one for each region.</p> <p>Then the main question is : how to define these regions ?</p> <p>Important</p> <p>The AntakIA method consists in finding clusters in two spaces at the same time : the space with our <code>X</code> values (aka \"values space\" or \"VS\"), and a space with the same dimensionality, but with the explanations (e.g. shapley values, or LIME values) for each observation. We call the latter the \"explanations space\" or \"ES\". Put in another way, VS shows the values as we seee them, and ES shows the same values, but as the trained model sees them.</p> <p>Then, finding relevant regions consists in finding clusters in VS corresponding to clusters in ES. Then we find regions where records are alike and records are explained similarly. Then, on these regions we can find simple models, with fewer variables that the initial model and consistent explanations. We may confidently replace the former \"black box\".</p>"},{"location":"examples/california2/#the-different-dataset-at-stake","title":"The different dataset at stake","text":"<p>We introduced the idea of \"explanation values\". To get an intuition of it, let's consider a dataset with only 2 variables x1 and x2. Now let's take a look at one specific record A. We can plot it on a 2D value space. To compute the explanation values, different methods exist. In AntakIA we use two of them : SHAP and LIME. In the \"explanations space\" A's coordinates or the importance of variables x1 and x2 according to SHAP for the predictions by the model :</p> <p></p> <p>This is a very simple example : since our California housing dataset <code>X</code> has 8 variables, we would need to display an 8-dimension space ! Of course it's not feasible : a human can only understand 2D ond 3D representations.</p> <p>Hence the idea of dimensionality reduction. Various techniques can project a N-dimension space in 2 or 3 dimensions. Some are illustrated below :</p> <p></p> <p>These 2D plots illustrate our California housing dataset projected in 2D using the PCA, t-SNE and PaCMAP techniques. Note, AntakIA also proposes the UMAP method.</p> <p>These dimensionality reduction technique can also project in 3D :</p> <p></p>"},{"location":"examples/california2/#the-splash-screen","title":"The splash screen","text":"<p>When you type <code>atk.start_gui()</code> the application shows a splash screen first :</p> <p></p> <p>AntakIA needs computed explanation values in order to display the ES.</p> <p>If you passed to AntakIA some pre-computed explanation values, such as <code>shap_values</code>, then you'll see in the splah screen that the first progress bar isn't active and its status is \u00ecmported explained values. Otherwise you would have to wait for its computation.</p> <p>As we saw earlier, we also need to compute the dimensionality reductions for both VS and ES spaces. Since we display the values in 2D and 3D, we have 4 computations. That's what is shown on the second progres bar of the splash screen. Note we only compute projections for the default reduction technique.</p> <p>Note</p> <p>You can put in your working directory an <code>.env</code> file with some default values for AntakIA.</p> <p>Below is an example of such an .env file :</p> <pre><code>DEFAULT_EXPLANATION_METHOD = 1 # 1 for SHAP (default), 2 for LIM\nDEFAULT_DIMENSION = 2 # 2 (default) or 3\nDEFAULT_PROJECTION = PaCMAP # PCA, UMAP or PacMAP (default)\n\nMAX_DOTS = 5000 # default. Max dots to display, for you CPU sake\n\n# Rule format\nUSE_INTERVALS_FOR_RULES = 'True' # intervals use the [a,b] notation\nSHOW_LOG_MODULE_WIDGET = 'False' # default, a logging tool for debug\n\n#Auto cluster\nMIN_POINTS_NUMBER = 100 #minumum number of point to allow autocluster and substitution\n</code></pre>"},{"location":"examples/california2/#the-main-window","title":"The main window","text":"<p>Here is an explanation fo the main window generic tools :</p> <p></p>"},{"location":"examples/california2/#understanding-the-antakia-worlflow","title":"Understanding the Antakia worlflow","text":"<p>AntakIA workflow can be summarized as below :</p> <ol> <li>find some points in one space such as the corresponding points in the other space aren't too sparse / are grouped</li> <li>find rules on the dataset variables that matches this selection</li> <li>adjust these rules according to your needs</li> <li>add this rules-defined zone to your list of \"region\"</li> <li>chose a submodel for substitution</li> <li>start again from step 1 with the remaining points</li> </ol>"},{"location":"examples/california2/#applying-antakia-workflow-on-our-dataset","title":"Applying AntakIA workflow on our dataset","text":""},{"location":"examples/california2/#1-find-a-good-selection","title":"1. Find a \"good\" selection","text":"<p>The example below is a pretty good example :</p> <p></p> <p>As previously explained, the idea is to find regions homogenous in both spaces at the same time.</p> <p>Using the \"lasso\" tool, you can select points in one space, and then, see the corresponding selection in the other space.</p> <p>Important</p> <p>If you want to empty your selection, just do a multiple click anywhere in a grey area.</p> <p>In this example, we see a region in the VS space, with a relatively homogeneous counterpart in the ES space :</p> <ul> <li>dots in VS are grouped : they are closed (the distance is small), so they are similar. In our example, this means we have selected block groups with similar attributes</li> <li>dots in the ES are also groupes : this means the model predicts their price values similarly, ie. their descriptive variables play a nearly identical role in the prediction</li> </ul>"},{"location":"examples/california2/#2-find-rules-matching-our-selection","title":"2. Find rules matching our selection","text":"<p>Whenever the selection is not empty, you'll see a blue \"Find rules\" button :</p> <p></p> <p>You can click it. It launches an algoritm called Skope rules that tries to find rules to describe your selection :</p> <p></p> <p>Actually, Skope rules is a binary classifier : it predicts wether a record belongs to your selection (positive) or not (negative). The dots in blue correspond to the positive records of the rules found, for both VS and ES.</p> <p>Under the title \"Rule(s) applied to the values space\", you can read the rules that have been found : Here, it is <code>MedInc &lt;= 7.409 and AveRooms &gt;= 5.502 and Latitude &lt;= 37.355</code>.</p> <p>Note</p> <p>Rules have only been found in the VS. As a matter of fact, the Skope rules algorithm doesn't systematically find rules in both spaces. Here, it didn't find rules (expressed with a subset of our 8 variables) able to describe the ES selection (with explained values) effectively.</p>"},{"location":"examples/california2/#3-adjust-the-rules","title":"3. Adjust the rules","text":"<p>On the last picture, you see, under the rules, 3 sliders to adjust the thresholds of the rules, one for each variable.</p> <p>Working with a \"market expert\" (here, a real estate expert) you may adjust those thresholds to match specific values.</p>"},{"location":"examples/california2/#4-validate-the-region","title":"4. Validate the region","text":"<p>When you're done, you can click on the \"validate rules\" button</p> <p>When a set of rules has been validated, AntakIA show another tab named \"Regions\" :</p> <p></p> <p>You see the region has been given a color, here : red.</p>"},{"location":"examples/california2/#5-substitute-the-initial-model-with-a-surrogate-model","title":"5. Substitute the initial model with a surrogate model","text":"<p>Now you can either go back to step 1 and find another region, or find a submodel for substitution. Let's do this.</p> <p>In the table, select the region with the checkbox, then click on the \"substitute\" button.</p> <p>What you see is a proposal of submodels :</p> <p></p> <p>You can read the performance of various surrogate models, compared (delta) with the original model.</p> <p>You can select one model and \"validate sub-model\" to add the submodel in your region list.</p>"},{"location":"examples/california2/#the-auto-clustering-way","title":"The auto-clustering way","text":"<p>This dyadic exploration provides many insights both for the data scientists, the \"market expert person\" and compliance officer.</p> <p>Instead of finding each region one by one, you can try our auto-clustering method. In the \"Regions\" tab, click on the blue button \"auto-clustering\". You can uncheck the \"automatic numnber of clusters\" if you want to force it.</p> <p>Below is an example of what you can get :</p> <p></p> <p>It's often a good way to start, then refine your regions !</p> <p>Hope you enjoyed this tutorial !</p>"},{"location":"examples/titanic/","title":"Titanic Tutorial","text":"<p>For this tutorial we explore a well known toy dataset, representing all the passengers of the Titanic. The goal is to predict whether they will survive the collision with the iceberg.</p> <p>This tuturial presents how to use Antakia with a classification problem</p>"},{"location":"examples/titanic/#data-overview","title":"Data Overview","text":"<p>the dataset is composed by 12 columns :</p> Variable Description PassengerId The passenger number Survived Target variable Pclass Travel class Name Passenger's name Sex Gender Age Age in years SibSp No. of siblings / spouses aboard the Titanic Parch No. of parents / children aboard the Titanic Ticket Ticket number Fare Passenger fare Cabin Cabin number Embarked Embarked"},{"location":"examples/titanic/#data-collection-and-preparation","title":"data collection and preparation.","text":"<p>Let's get's the data and prepare it :</p> <p>To get the data simply run :</p> <pre><code>import pandas as pd\nfrom antakia.utils.examples import fetch_dataset\ndataset = fetch_dataset('titanic', 'train')\n</code></pre> <p>Then to prepare it :</p> <pre><code>dataset['Age'] = dataset['Age'].fillna(dataset['Age'].mean())\ndataset['Embarked'] = dataset['Embarked'].fillna('S')\nSex = pd.get_dummies(dataset['Sex'], drop_first=True)\nEmbarked = pd.get_dummies(dataset['Embarked'], drop_first=True)\ndataset = dataset.drop(['Sex', 'Embarked', 'Name', 'Ticket', 'Cabin', 'PassengerId'], axis=1)\ndataset = pd.concat([dataset, Sex, Embarked], axis=1)\n</code></pre> <p>The preparation include 3 steps :</p> <ul> <li>fill missing values</li> <li>one hot encode categorical variable</li> <li>remove columns with high cardinality</li> </ul> <p>Then we shuffle it and splut into test and train, and separate features and target :</p> <pre><code>dataset = dataset.sample(len(dataset))\nlimit = int(2000 / 0.8)\ndataset = dataset.iloc[:limit]\nsplit_row = int(len(dataset) * 0.8)\ndf_train = dataset[:split_row]\ndf_test = dataset[split_row:]\n\nX_train = df_train.drop('Survived', axis=1)  # the dataset\ny_train = df_train['Survived']  # the target variable\n\nX_test = df_test.drop('Survived', axis=1)  # the dataset\ny_test = df_test['Survived']  # the target variable\n</code></pre> <p>Finally let's train a machine learning model, for example a random forest classifier</p> <pre><code>from sklearn.ensemble import RandomForestClassifier\n\nparameters = {\n    'bootstrap': True,\n    'criterion': 'entropy',\n    'max_depth': 15,\n    'max_features': 2,\n    'min_samples_leaf': 5,\n    'min_samples_split': 8,\n    'n_estimators': 10\n}\nmodel = RandomForestClassifier(random_state=42, **parameters)\nmodel.fit(X_train, y_train)\n</code></pre> <p>let's see how it performs :</p> <p></p>"},{"location":"examples/titanic/#model-exploration-with-antakia","title":"Model exploration with Antakia:","text":"<p>let's explore what the model learned and if we can improve it.</p> <p>to run AntakIA :</p> <pre><code>from antakia.antakia import AntakIA\n\natk = AntakIA(\n    X_train, y_train,\n    model,\n    X_test=X_test, y_test=y_test,\n)\n</code></pre> <p>Note we can force antakia to classification behavior by passing <code>problem_category='classification'</code> as argument :</p> <pre><code>atk = AntakIA(\n    X_train, y_train,\n    model,\n    X_test=X_test, y_test=y_test,\n    problem_category='classification'\n)\n</code></pre> <p>and display the gui :</p> <pre><code>atk.start_gui()\n</code></pre> <p></p>"},{"location":"examples/titanic/#1-data-exploration","title":"1. Data exploration:","text":"<p>We can see that 5 different blobs appear, with very different survivor rates:</p> <p>By selecting the top right one, we can see that 97% of females, that paid between 48$ and 188$ survived</p> <p></p> <p>We can edit the rule to adapt it if necessary </p> <p>Once we are done, let's validate it</p> <p>If we select the big blob, we can see that it correspond to several blobs in the Explanation space, </p> <p>Let's select one blob in the explanation space</p> <p> This new segment is more homogenous, event if we did not capare it perfectly.</p> <p>By iterating this process we can divide our space into 7 regions : </p>"},{"location":"examples/titanic/#2-region-refinement","title":"2. Region refinement :","text":"<p>If the identified regions are not as good as desired, we can merge, divide or delete some of them.</p> <p>We can for example merge the region 2 and 4</p> <p></p>"},{"location":"examples/titanic/#3-model-substitution","title":"3. Model substitution","text":"<p>Once the main behaviors have been extracted, we can explore the model in each of these regions:</p> <p>For example the performance of the trained model on the region 5 is as good as the Average baseline model. inside this region the model did not learn anything more.</p> <p></p> <p>For the region 2, the linear regression performs better than the original model :</p> <p></p> <p>On the right side we can explore the selected model to understand how the prediction was made.</p>"},{"location":"examples/titanic/#conclusion","title":"Conclusion","text":"<p>In this Tutorial we were able to explore a classification model on the titanic dataset. We identified 6 main regions :</p> <ol> <li>Fare \u2264 9.662499904632568 and male and Embarked = S<ul> <li>11% survivorship</li> <li>best model : average baseline</li> </ul> </li> <li>Pclass = 2 or 3 and Fare &gt; 10.335400104522705 and male<ul> <li>21% survivorship</li> <li>best model : customer model</li> </ul> </li> <li>Pclass = 2 or 3 and female and not Embarked = Q<ul> <li>63% survivorship</li> <li>best model : linear regression (Pclass, Age, SibSp)</li> </ul> </li> <li>Pclass = 1 and male<ul> <li>45% survivorship</li> <li>best model : average baseline</li> </ul> </li> <li>48.29999923706055 &lt; Fare \u2264 188.1020965576172 and female<ul> <li>97% survivorship</li> <li>best model : average baseline</li> </ul> </li> <li>Fare \u2264 59.5625 and Embarked = Q<ul> <li>36%</li> <li>best model : linear regression (male, Parch)</li> </ul> </li> </ol> <p>The new model, build with AntakIA, is explanaible and performs better than the original random forest. We managed to improve the performance by 3% on the test set and gained kwnoledge about which passenger did survived or not. </p>"},{"location":"examples/wages/","title":"Wages","text":"<p>This tutorial plays with a toy dataset, using self generated data. We've purposely defined a very simple and segmented by design phenomenon, added some noise, and then trained a complex enough model. We then use AntakIA in a blackbox approach, so try and identify the latent regions... and yes, we added so gendered-base biais, so see if we can spot it too. off we go !</p>"},{"location":"examples/wages/#the-segmented-phenomenon","title":"the segmented phenomenon","text":""},{"location":"examples/wages/#the-dataset","title":"The dataset !","text":"<p>The wage (y) is a function of the age, the education level and the gender. We generated the data according to the following rules with some noise. - young people(&lt;25) have aleatory low salaries - young adult (&lt;40) increase their salaries according to their education level, and experience (age) - people &gt;40 have the same rules that younger people, but with a difference (Women are penalized...)</p> <p></p>"},{"location":"examples/wages/#the-cheatsheet","title":"The cheatsheet","text":"<p>We do have 4 natural regions :  1. people &lt;25 with aleatory values around a low average 2. people between 25 and 40 with linear dependency on age and education 3. men over 40, with linear dependency on age and education and discrimination 4. women over 40, with linear dependency on age and education and discrimination and slight disadvantage versus men We now hope that AntakIA will help us identifiy those zones...</p>"},{"location":"examples/wages/#the-model","title":"The model","text":"<p>We trained an XGBoost to predict the wage. We confirm the global monotonicity of the model through the representation of beeswarms with SHAP library.</p> <p> the segments are note obvious...</p>"},{"location":"examples/wages/#exploring-with-antakia","title":"exploring with AntakIA","text":""},{"location":"examples/wages/#dyadic-display-es-and-vs","title":"Dyadic display : ES and VS","text":"<p>we chose to use the linear reduction of dimension (PCA) for both the Explanation Space (ES) and the Value Space (VS). Here what comes to the fore :</p> <p></p>"},{"location":"examples/wages/#exploring-through-the-es","title":"Exploring through the ES","text":"<p>The true innovation of AntakIA relies in taking into account the 'knowledge' retrieved from AI models, but hidden in the 'blackbox'... To unveil that, we explore the ES. We identify that two clusters of similar wage levels are to be seen on the right. Let's select them in the ES : good news !  - we find some simple rules describing the selection in the VS, and the ES - all the points in the VS are very close to one another Hopefully, we'll be able to define a first region...</p> <p></p>"},{"location":"examples/wages/#refining-a-region","title":"Refining a region","text":"<p>AntakIA enables to explore at the predictor-level what the selection / region looks like.  The first predictor used in the rule is the age (~&lt; 25!):</p> <p></p> <p>we might extend slightly the value of the threshold and observe the relevance of the modification : the added points appear in orange either on the distribution...</p> <p></p> <p>... or in the dyadic visualisation : we can see that the added points 'jump' on other clusters in the ES... we should stay with the original value, to make the regions as consistent as possible, explanation wise. Nonetheless, we can see that some seemingly consistent points of the manual selection are not included in our rule (represented in red)</p> <p></p> <p>The second predictor in this rule is the education level :</p> <p></p> <p>The distribution of the selection is not different from the global distribution. There could be no reason to cut the lower part of it... </p> <p></p> <p>So finally : - age : we reverted to the inital value - edu : we changeg the threshold to the minimum</p> <p>we eventually got this representation : it looks like a region !</p> <p></p>"},{"location":"examples/wages/#substituing-by-a-simpler-model-on-a-region","title":"Substituing by a simpler model on a region","text":"<p>We chose to go on to the next step : can we define a simpler model than the original one ? We push the 'validate rule' button.</p> <p></p> <p>We reach the second screen listing the regions defined (one, so far). Let's select it, and push the 'substitute' button.</p> <p></p> <p>AntakIA automatically fits some alternate simpler, and more explainable models, benchmarking their comparative performance versus the original one.</p> <p></p> <p>This is where the Data scientist and the business expert have to ponder together over the subject, and come to a mutual conclusion. And especially, the moment where some DS know how should come into consideration. For example here, there does not seem to have a huge difference in performance, so the bias-variance trade off should advocate for choosing the simplest model.  - the original model show very little dependence on any predictor in the range of the region == age&lt;25 (looks at the PDP displays on the right, and the Feature Importance) - other present very diverse behaviours (even decreasing with the age after age &gt;25, or with the education)</p> <p>so we chose stick to the simplest model. The original data were generated with pure noise around and average value : chosing this one could be a nice try ! let's go for it. We push the 'Validate Sub-model' button</p> <p></p> <p>AntakIA brings us back to the region tab, with a fresh new model on the region, briefly described.</p> <p></p> <p>Congrats ! we've just gone through the creation of our first region, and regional surrogate model :)</p>"},{"location":"examples/wages/#substituing-the-whole-model","title":"Substituing the whole model","text":""},{"location":"examples/wages/#going-on-with-manual-selection","title":"going on with manual selection","text":"<p>You can just follow the above steps again and again, so that all the points of your dataset are tackled, assigned to a region, be it rule defined (whenever possible) or not. But we also added a trick...</p>"},{"location":"examples/wages/#auto-defining-regions-im-feeling-lucky","title":"auto-defining regions : 'I'm feeling lucky'","text":"<p>One other way to define other regions is to ask AntakIA to try and identify the regions by itself. Starting after the creation of a first region e.g., we can also push the 'auto-clustering' button. Then AntakIA tries to run an automatic dyadic auto-clustering. Here is what we get :</p> <p></p> <p>AntakIA automatically suggests to split the remaining data along the 'sex' value. We could ask him to dive deeper : that's why the 'divide' stands for.</p> <p></p> <p>Selecting the red cluster, and applying the function gives the following result :</p> <p></p> <p>Two conclusions : - AntakIA did propose a split at age 40 : cool ! - some yellow points are clustered in a small area (people close to 25) : we see no obvious reason what they should keep separated from the green one.</p> <p>So we added a 'merge' button. Selecting yellow and green regions, and merging them give us the following result : (the rule is slightly modified, with a lower threshold for the age)</p> <p></p> <p>Finally, doing the same with the remaining blue cluster, we obtain :</p> <p></p> <p>That'a a nice try :) We've managed to uncover the building segmentation ! OK, it's easier when you know where you have to go... nonetheless,  - the thresholds have been automatically identified - the substitution models proposed were leading naturally to a noisy average, or to linear GAM, which is a correct guess We'll go into more details on that last point on a second tutorial...</p> <p>Juste note : to finish the substitution, just repeat the 'substitute' then 'validate sub-model', and you're done !</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>antakia<ul> <li>antakia</li> <li>config</li> <li>explanation<ul> <li>explanation_method</li> <li>explanations</li> </ul> </li> <li>gui<ul> <li>antakia_logo</li> <li>colorTable</li> <li>data_store</li> <li>explanation_values</li> <li>gui</li> <li>high_dim_exp<ul> <li>figure_display</li> <li>highdimexplorer</li> <li>projected_value_bank</li> <li>projected_values_selector</li> </ul> </li> <li>metadata</li> <li>progress_bar</li> <li>ruleswidget</li> <li>tabs<ul> <li>model_explorer</li> <li>tab1</li> </ul> </li> <li>widget_utils</li> <li>widgets</li> </ul> </li> <li>utils<ul> <li>checks</li> <li>dummy_datasets</li> <li>examples</li> <li>logging</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/antakia/__init__/","title":"init","text":""},{"location":"reference/antakia/__init__/#antakia.__author__","title":"<code>__author__ = 'AI-vidence'</code>  <code>module-attribute</code>","text":"<p>This is antakia package documentation.</p>"},{"location":"reference/antakia/antakia/","title":"antakia","text":""},{"location":"reference/antakia/antakia/#antakia.antakia.AntakIA","title":"<code>AntakIA</code>","text":"<p>AntakIA class. </p> <p>Antakia instances provide data and methods to explain a ML model.</p>"},{"location":"reference/antakia/antakia/#antakia.antakia.AntakIA--instance-attributes","title":"Instance attributes","text":"<p>X : pd.DataFrame the training dataset y : pd.Series the target value model : Model     the model to explain variables : a list of Variables, describing X_list[0] X_test : pd.DataFrame the test dataset y_test : pd.Series the test target value score : reference scoring function</p> Source code in <code>src/antakia/antakia.py</code> <pre><code>class AntakIA:\n    \"\"\"AntakIA class. \n\n    Antakia instances provide data and methods to explain a ML model.\n\n    Instance attributes\n    -------------------\n    X : pd.DataFrame the training dataset\n    y : pd.Series the target value\n    model : Model\n        the model to explain\n    variables : a list of Variables, describing X_list[0]\n    X_test : pd.DataFrame the test dataset\n    y_test : pd.Series the test target value\n    score : reference scoring function\n    \"\"\"\n\n    def __init__(\n            self,\n            X: pd.DataFrame,\n            y: pd.Series,\n            model,\n            variables: DataVariables | List[Dict[str, Any]] | pd.DataFrame | None = None,\n            X_test: pd.DataFrame = None,\n            y_test: pd.Series = None,\n            X_exp: pd.DataFrame | None = None,\n            score: callable | str = 'auto',\n            problem_category: str = 'auto'\n    ):\n        \"\"\"\n        AntakiIA constructor.\n\n        Parameters:\n            X : pd.DataFrame the training dataset\n            y : pd.Series the target value\n            model : Model\n                the model to explain\n            variables : a list of Variables, describing X_list[0]\n            X_test : pd.DataFrame the test dataset\n            y_test : pd.Series the test target value\n            score : reference scoring function\n        \"\"\"\n\n        load_dotenv()\n\n        if not is_valid_model(model):\n            raise ValueError(model, \" should implement predict and score methods\")\n        X, y, X_exp = self._preprocess_data(X, y, X_exp)\n        X_test, y_test, _ = self._preprocess_data(X_test, y_test, None)\n\n        self.X = X\n        if y.ndim &gt; 1:\n            y = y.squeeze()\n        self.y = y.astype(float)\n\n        self.X_test = X_test\n        if y_test is not None and y_test.ndim &gt; 1:\n            y_test = y_test.squeeze()\n        self.y_test = y_test\n\n        self.model = model\n\n        self.X_exp = X_exp\n\n        self.problem_category = self._preprocess_problem_category(problem_category, model, X)\n        self.score = self._preprocess_score(score, self.problem_category)\n\n        self.set_variables(X, variables)\n\n        self.gui = GUI(\n            self.X,\n            self.y,\n            self.model,\n            self.variables,\n            self.X_test,\n            self.y_test,\n            self.X_exp,\n            self.score,\n            self.problem_category\n        )\n\n    def set_variables(self, X, variables):\n        if variables is not None:\n            if isinstance(variables, list):\n                self.variables: DataVariables = Variable.import_variable_list(variables)\n                if len(self.variables) != len(X.columns):\n                    raise ValueError(\"Provided variable list must be the same length of the dataframe\")\n            elif isinstance(variables, pd.DataFrame):\n                self.variables = Variable.import_variable_df(variables)\n            else:\n                raise ValueError(\"Provided variable list must be a list or a pandas DataFrame\")\n        else:\n            self.variables = Variable.guess_variables(X)\n\n    def start_gui(self) -&gt; GUI:\n        return self.gui.show_splash_screen()\n\n    def export_regions(self):\n        return self.gui.region_set\n\n    def _preprocess_data(self, X: pd.DataFrame, y, X_exp: pd.DataFrame | None):\n        if isinstance(X, np.ndarray):\n            X = pd.DataFrame(X)\n        if isinstance(X_exp, np.ndarray):\n            X_exp = pd.DataFrame(X_exp)\n        if isinstance(y, np.ndarray):\n            y = pd.Series(y)\n\n        X.columns = [str(col) for col in X.columns]\n        if X_exp is not None:\n            X_exp.columns = X.columns\n\n        if X_exp is not None:\n            pd.testing.assert_index_equal(X.index, X_exp.index, check_names=False)\n            if X.reindex(X_exp.index).iloc[:, 0].isna().sum() != X.iloc[:, 0].isna().sum():\n                raise IndexError('X and X_exp must share the same index')\n        pd.testing.assert_index_equal(X.index, y.index, check_names=False)\n        return X, y, X_exp\n\n    def _preprocess_problem_category(self, problem_category: str, model, X: pd.DataFrame) -&gt; ProblemCategory:\n        if problem_category not in [e.name for e in ProblemCategory]:\n            raise ValueError('Invalid problem category')\n        if problem_category == 'auto':\n            if hasattr(model, 'predict_proba'):\n                return ProblemCategory['classification_with_proba']\n            pred = self.model.predict(self.X.sample(min(100, len(self.X))))\n            if len(pred.shape) &gt; 1 and pred.shape[1] &gt; 1:\n                return ProblemCategory['classification_proba']\n            return ProblemCategory['regression']\n        if problem_category == 'classification':\n            if hasattr(model, 'prodict_proba'):\n                return ProblemCategory['classification_with_proba']\n            pred = model.predict(X.sample(min(100, len(X))))\n            if len(pred.shape) &gt; 1 and pred.shape[1] &gt; 1:\n                return ProblemCategory['classification_proba']\n            return ProblemCategory['classification_label_only']\n        return ProblemCategory[problem_category]\n\n    def _preprocess_score(self, score, problem_category):\n        if callable(score):\n            return score\n        if score != 'auto':\n            return score\n        if problem_category == ProblemCategory.regression:\n            return 'mse'\n        return 'accuracy'\n</code></pre>"},{"location":"reference/antakia/antakia/#antakia.antakia.AntakIA.__init__","title":"<code>__init__(X, y, model, variables=None, X_test=None, y_test=None, X_exp=None, score='auto', problem_category='auto')</code>","text":"<p>AntakiIA constructor.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>pd.DataFrame the training dataset</p> required <code>y</code> <p>pd.Series the target value</p> required <code>model</code> <p>Model the model to explain</p> required <code>variables</code> <p>a list of Variables, describing X_list[0]</p> <code>None</code> <code>X_test</code> <p>pd.DataFrame the test dataset</p> <code>None</code> <code>y_test</code> <p>pd.Series the test target value</p> <code>None</code> <code>score</code> <p>reference scoring function</p> <code>'auto'</code> Source code in <code>src/antakia/antakia.py</code> <pre><code>def __init__(\n        self,\n        X: pd.DataFrame,\n        y: pd.Series,\n        model,\n        variables: DataVariables | List[Dict[str, Any]] | pd.DataFrame | None = None,\n        X_test: pd.DataFrame = None,\n        y_test: pd.Series = None,\n        X_exp: pd.DataFrame | None = None,\n        score: callable | str = 'auto',\n        problem_category: str = 'auto'\n):\n    \"\"\"\n    AntakiIA constructor.\n\n    Parameters:\n        X : pd.DataFrame the training dataset\n        y : pd.Series the target value\n        model : Model\n            the model to explain\n        variables : a list of Variables, describing X_list[0]\n        X_test : pd.DataFrame the test dataset\n        y_test : pd.Series the test target value\n        score : reference scoring function\n    \"\"\"\n\n    load_dotenv()\n\n    if not is_valid_model(model):\n        raise ValueError(model, \" should implement predict and score methods\")\n    X, y, X_exp = self._preprocess_data(X, y, X_exp)\n    X_test, y_test, _ = self._preprocess_data(X_test, y_test, None)\n\n    self.X = X\n    if y.ndim &gt; 1:\n        y = y.squeeze()\n    self.y = y.astype(float)\n\n    self.X_test = X_test\n    if y_test is not None and y_test.ndim &gt; 1:\n        y_test = y_test.squeeze()\n    self.y_test = y_test\n\n    self.model = model\n\n    self.X_exp = X_exp\n\n    self.problem_category = self._preprocess_problem_category(problem_category, model, X)\n    self.score = self._preprocess_score(score, self.problem_category)\n\n    self.set_variables(X, variables)\n\n    self.gui = GUI(\n        self.X,\n        self.y,\n        self.model,\n        self.variables,\n        self.X_test,\n        self.y_test,\n        self.X_exp,\n        self.score,\n        self.problem_category\n    )\n</code></pre>"},{"location":"reference/antakia/config/","title":"config","text":""},{"location":"reference/antakia/explanation/__init__/","title":"init","text":"<p>This is antakia.explanation package documentation.</p>"},{"location":"reference/antakia/explanation/explanation_method/","title":"explanation_method","text":""},{"location":"reference/antakia/explanation/explanation_method/#antakia.explanation.explanation_method.ExplanationMethod","title":"<code>ExplanationMethod</code>","text":"<p>             Bases: <code>LongTask</code></p> <p>Abstract class (see Long Task) to compute explaination values for the Explanation Space (ES)</p> <p>Attributes model : the model to explain explanation_method : SHAP or LIME</p> Source code in <code>src/antakia/explanation/explanation_method.py</code> <pre><code>class ExplanationMethod(LongTask):\n    \"\"\"\n    Abstract class (see Long Task) to compute explaination values for the Explanation Space (ES)\n\n    Attributes\n    model : the model to explain\n    explanation_method : SHAP or LIME\n    \"\"\"\n\n    # Class attributes\n    NONE = 0  # no explanation, ie: original values\n    SHAP = 1\n    LIME = 2\n\n    def __init__(\n            self,\n            explanation_method: int,\n            X: pd.DataFrame,\n            model,\n            task_type,\n            progress_updated: callable = None,\n    ):\n        if not ExplanationMethod.is_valid_explanation_method(explanation_method):\n            raise ValueError(explanation_method, \" is a bad explanation method\")\n        self.explanation_method = explanation_method\n        super().__init__(X, progress_updated)\n        self.task_type = task_type\n        self.model = model\n\n    @staticmethod\n    def is_valid_explanation_method(method: int) -&gt; bool:\n        \"\"\"\n        Returns True if this is a valid explanation method.\n        \"\"\"\n        return (\n                method == ExplanationMethod.SHAP\n                or method == ExplanationMethod.LIME\n                or method == ExplanationMethod.NONE\n        )\n\n    @staticmethod\n    def explanation_methods_as_list() -&gt; list:\n        return [ExplanationMethod.SHAP, ExplanationMethod.LIME]\n\n    @staticmethod\n    def explain_method_as_str(method: int) -&gt; str:\n        if method == ExplanationMethod.SHAP:\n            return \"SHAP\"\n        elif method == ExplanationMethod.LIME:\n            return \"LIME\"\n        else:\n            raise ValueError(method, \" is a bad explanation method\")\n\n    @staticmethod\n    def explain_method_as_int(method: str) -&gt; int:\n        if method.upper() == \"SHAP\":\n            return ExplanationMethod.SHAP\n        elif method.upper() == \"LIME\":\n            return ExplanationMethod.LIME\n        else:\n            raise ValueError(method, \" is a bad explanation method\")\n</code></pre>"},{"location":"reference/antakia/explanation/explanation_method/#antakia.explanation.explanation_method.ExplanationMethod.is_valid_explanation_method","title":"<code>is_valid_explanation_method(method)</code>  <code>staticmethod</code>","text":"<p>Returns True if this is a valid explanation method.</p> Source code in <code>src/antakia/explanation/explanation_method.py</code> <pre><code>@staticmethod\ndef is_valid_explanation_method(method: int) -&gt; bool:\n    \"\"\"\n    Returns True if this is a valid explanation method.\n    \"\"\"\n    return (\n            method == ExplanationMethod.SHAP\n            or method == ExplanationMethod.LIME\n            or method == ExplanationMethod.NONE\n    )\n</code></pre>"},{"location":"reference/antakia/explanation/explanations/","title":"explanations","text":""},{"location":"reference/antakia/explanation/explanations/#antakia.explanation.explanations.LIMExplanation","title":"<code>LIMExplanation</code>","text":"<p>             Bases: <code>ExplanationMethod</code></p> <p>LIME computation class.</p> Source code in <code>src/antakia/explanation/explanations.py</code> <pre><code>class LIMExplanation(ExplanationMethod):\n    \"\"\"\n    LIME computation class.\n    \"\"\"\n\n    def __init__(self, X: pd.DataFrame, model, task_type, progress_updated: callable = None):\n        super().__init__(ExplanationMethod.LIME, X, model, task_type, progress_updated)\n\n    @property\n    def mode(self):\n        print(self.task_type)\n        if self.task_type == ProblemCategory.regression:\n            return 'regression'\n        else:\n            return 'classification'\n\n    def compute(self) -&gt; pd.DataFrame:\n        self.publish_progress(0)\n\n        explainer = lime.lime_tabular.LimeTabularExplainer(\n            self.X.sample(min(len(self.X), 500)).values,\n            feature_names=self.X.columns,\n            verbose=False,\n            mode=self.mode,\n            discretize_continuous=False\n        )\n\n        values_lime = pd.DataFrame(\n            np.zeros(self.X.shape),\n            index=self.X.index,\n            columns=self.X.columns\n        )\n        progress = 0\n        if self.mode == 'regression':\n            predict_fct = self.model.predict\n            i = 0\n        else:\n            i = 1\n            if hasattr(self.model, 'predict_proba'):\n                predict_fct = self.model.predict_proba\n            else:\n                predict_fct = self.model.predict\n        for index, row in self.X.iterrows():\n            exp = explainer.explain_instance(row.values, predict_fct)\n\n            values_lime.loc[index] = pd.Series(exp.local_exp[i], index=explainer.feature_names).str[1]\n            progress += 100 / len(self.X)\n            self.publish_progress(int(progress))\n        self.publish_progress(100)\n        return values_lime\n</code></pre>"},{"location":"reference/antakia/explanation/explanations/#antakia.explanation.explanations.SHAPExplanation","title":"<code>SHAPExplanation</code>","text":"<p>             Bases: <code>ExplanationMethod</code></p> <p>SHAP computation class.</p> Source code in <code>src/antakia/explanation/explanations.py</code> <pre><code>class SHAPExplanation(ExplanationMethod):\n    \"\"\"\n    SHAP computation class.\n    \"\"\"\n\n    def __init__(self, X: pd.DataFrame, model, task_type, progress_updated: callable = None):\n        super().__init__(ExplanationMethod.SHAP, X, model, task_type, progress_updated)\n\n    @property\n    def link(self):\n        if self.task_type == ProblemCategory.regression:\n            return \"identity\"\n        return \"logit\"\n\n    def compute(self) -&gt; pd.DataFrame:\n        self.publish_progress(0)\n        try:\n            explainer = shap.TreeExplainer(self.model)\n        except:\n            explainer = shap.KernelExplainer(self.model.predict, self.X.sample(min(200, len(self.X))), link=self.link)\n        chunck_size = 200\n        shap_val_list = []\n        for i in range(0, len(self.X), chunck_size):\n            explanations = explainer.shap_values(self.X.iloc[i:i + chunck_size])\n            if isinstance(explanations, list):\n                # classification, use only class 1 probabilities\n                explanations = explanations[-1]\n            shap_val_list.append(\n                pd.DataFrame(explanations, columns=self.X.columns, index=self.X.index[i:i + chunck_size]))\n            self.publish_progress(int(100 * (i * chunck_size) / len(self.X)))\n        shap_values = pd.concat(shap_val_list)\n        self.publish_progress(100)\n        return shap_values\n</code></pre>"},{"location":"reference/antakia/explanation/explanations/#antakia.explanation.explanations.compute_explanations","title":"<code>compute_explanations(X, model, explanation_method, task_type, callback)</code>","text":"<p>Generic method to compute explanations, SHAP or LIME</p> Source code in <code>src/antakia/explanation/explanations.py</code> <pre><code>def compute_explanations(X: pd.DataFrame, model, explanation_method: int, task_type,\n                         callback: callable) -&gt; pd.DataFrame:\n    \"\"\" Generic method to compute explanations, SHAP or LIME\n    \"\"\"\n    if explanation_method == ExplanationMethod.SHAP:\n        return SHAPExplanation(X, model, task_type, callback).compute()\n    elif explanation_method == ExplanationMethod.LIME:\n        return LIMExplanation(X, model, task_type, callback).compute()\n    else:\n        raise ValueError(f\"This explanation method {explanation_method} is not valid!\")\n</code></pre>"},{"location":"reference/antakia/gui/__init__/","title":"init","text":""},{"location":"reference/antakia/gui/__init__/#antakia.gui.__author__","title":"<code>__author__ = 'AI-vidence'</code>  <code>module-attribute</code>","text":"<p>This is antakia.gui package documentation.</p>"},{"location":"reference/antakia/gui/antakia_logo/","title":"antakia_logo","text":""},{"location":"reference/antakia/gui/colorTable/","title":"colorTable","text":""},{"location":"reference/antakia/gui/colorTable/#antakia.gui.colorTable.ColorTable","title":"<code>ColorTable</code>","text":"<p>             Bases: <code>VuetifyTemplate</code></p> <p>table to display regions</p> Source code in <code>src/antakia/gui/colorTable.py</code> <pre><code>class ColorTable(v.VuetifyTemplate):\n    \"\"\"\n    table to display regions\n    \"\"\"\n    headers = traitlets.List([]).tag(sync=True, allow_null=True)\n    items = traitlets.List([]).tag(sync=True, allow_null=True)\n    selected = traitlets.List([]).tag(sync=True, allow_null=True)\n    colors = traitlets.List(colors).tag(sync=True)\n    template = traitlets.Unicode('''\n        &lt;template&gt;\n            &lt;v-data-table\n                v-model=\"selected\"\n                :headers=\"headers\"\n                :items=\"items\"\n                item-key=\"Region\"\n                show-select\n                :hide-default-footer=\"false\"\n                @item-selected=\"tableselect\"\n            &gt;\n            &lt;template #header.data-table-select&gt;&lt;/template&gt;\n            &lt;template v-slot:item.Region=\"{ item }\"&gt;\n              &lt;v-chip :color=\"item.color\" &gt;\n                {{ item.Region }}\n              &lt;/v-chip&gt;\n            &lt;/template&gt;\n            &lt;/v-data-table&gt;\n        &lt;/template&gt;\n        ''').tag(sync=True)  # type: ignore\n    disable_sort = True\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.callback = None\n\n    @staticmethod\n    def get_color(item):\n        return item.color\n\n    # @click:row=\"tableclick\"\n    # def vue_tableclick(self, data):\n    #     raise ValueError(f\"click event data = {data}\")\n\n    def set_callback(self, callback: callable):  # type: ignore\n        self.callback = callback\n\n    def vue_tableselect(self, data):\n        self.callback(data)\n</code></pre>"},{"location":"reference/antakia/gui/data_store/","title":"data_store","text":"<p>This is DataStore class.</p>"},{"location":"reference/antakia/gui/explanation_values/","title":"explanation_values","text":""},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues","title":"<code>ExplanationValues</code>","text":"<p>Widget to manage explanation values in charge on computing them when necessary</p> Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>class ExplanationValues:\n    \"\"\"\n    Widget to manage explanation values\n    in charge on computing them when necessary\n    \"\"\"\n    available_exp = ['Imported', 'SHAP', 'LIME']\n\n    def __init__(self, X: pd.DataFrame, y: pd.Series, model, task_type, on_change_callback: callable,\n                 disable_gui: callable, X_exp=None):\n        \"\"\"\n\n        Parameters\n        ----------\n        X: original train DataFrame\n        y: target variable\n        model: customer model\n        on_change_callback: callback to notify explanation change\n        X_exp: user provided explanations\n        \"\"\"\n        self.widget = None\n        self.X = X\n        self.y = y\n        self.model = model\n        self.task_type = task_type\n        self.on_change_callback = on_change_callback\n        self.disable_gui = disable_gui\n        self.initialized = False\n\n        # init dict of explanations\n        self.explanations: dict[str, pd.DataFrame | None] = {\n            exp: None for exp in self.available_exp\n        }\n\n        if X_exp is not None:\n            self.explanations[self.available_exp[0]] = X_exp\n\n        # init selected explanation\n        if X_exp is not None:\n            self.current_exp = self.available_exp[0]\n        else:\n            self.current_exp = self.available_exp[1]\n\n        self.build_widget()\n\n    def build_widget(self):\n        self.widget = v.Row(children=[\n            v.Select(  # Select of explanation method\n                label=\"Explanation method\",\n                items=[\n                    {\"text\": \"Imported\", \"disabled\": True},\n                    {\"text\": \"SHAP\", \"disabled\": True},\n                    {\"text\": \"LIME\", \"disabled\": True},\n                ],\n                class_=\"ml-2 mr-2\",\n                style_=\"width: 15%\",\n                disabled=False,\n            ),\n            v.ProgressCircular(  # exp menu progress bar\n                class_=\"ml-2 mr-2 mt-2\",\n                indeterminate=False,\n                color=\"grey\",\n                width=\"6\",\n                size=\"35\",\n            )\n        ])\n        # refresh select menu\n        self.update_explanation_select()\n        self.get_explanation_select().on_event(\"change\", self.explanation_select_changed)\n        # set up callback\n        self.get_progress_bar().reset_progress_bar()\n\n    def initialize(self, progress_callback):\n        \"\"\"\n        initialize class (compute explanation if necessary)\n        Parameters\n        ----------\n        progress_callback : callback to notify progress\n\n        Returns\n        -------\n\n        \"\"\"\n        if not self.has_user_exp:\n            # compute explanation if not provided\n            self.compute_explanation(config.DEFAULT_EXPLANATION_METHOD, progress_callback)\n        # ensure progress is at 100%\n        progress_callback(100, 0)\n        self.initialized = True\n\n    @property\n    def current_exp_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        currently selected explanation projected values instance\n        Returns\n        -------\n\n        \"\"\"\n        return self.explanations[self.current_exp]\n\n    @property\n    def has_user_exp(self) -&gt; bool:\n        \"\"\"\n        has the user provided an explanation\n        Returns\n        -------\n\n        \"\"\"\n        return self.explanations[self.available_exp[0]] is not None\n\n    def update_explanation_select(self):\n        \"\"\"\n        refresh explanation select menu\n        Returns\n        -------\n\n        \"\"\"\n        exp_values = []\n        for exp in self.available_exp:\n            if exp == 'Imported':\n                exp_values.append({\n                    \"text\": exp,\n                    'disabled': self.explanations[exp] is None\n                })\n            else:\n                exp_values.append({\n                    \"text\": exp + (' (compute)' if self.explanations[exp] is None else ''),\n                    'disabled': False\n                })\n        self.get_explanation_select().items = exp_values\n        self.get_explanation_select().v_model = self.current_exp\n\n    def get_progress_bar(self):\n        progress_widget = self.widget.children[1]\n        progress_bar = ProgressBar(progress_widget)\n        return progress_bar\n\n    def get_explanation_select(self):\n        \"\"\"\n        returns the explanation select menu\n        Returns\n        -------\n\n        \"\"\"\n        return self.widget.children[0]\n\n    def compute_explanation(self, explanation_method: int, progress_bar: callable):\n        \"\"\"\n        compute explanation and refresh widgets (select the new explanation method)\n        Parameters\n        ----------\n        explanation_method: desired explanation\n        progress_bar : progress bar to notify progress to\n\n        Returns\n        -------\n\n        \"\"\"\n        self.disable_gui(True)\n        self.current_exp = self.available_exp[explanation_method]\n        # We compute proj for this new PV :\n        x_exp = compute_explanations(self.X, self.model, explanation_method, self.task_type, progress_bar)\n        pd.testing.assert_index_equal(x_exp.columns, self.X.columns)\n\n        # update explanation\n        self.explanations[self.current_exp] = x_exp\n        # refresh front\n        self.update_explanation_select()\n        self.disable_gui(False)\n\n    def disable_selection(self, is_disabled: bool):\n        \"\"\"\n        disable widgets\n        Parameters\n        ----------\n        is_disabled = should disable ?\n\n        Returns\n        -------\n\n        \"\"\"\n        self.get_explanation_select().disabled = is_disabled\n\n    def explanation_select_changed(self, widget, event, data):\n        \"\"\"\n        triggered on selection of new explanation by user\n        explanation has already been computed (the option is enabled in select)\n        Parameters\n        ----------\n        widget\n        event\n        data: explanation name\n\n        Returns\n        -------\n\n        Called when the user chooses another dataframe\n        \"\"\"\n        if not isinstance(data, str):\n            raise KeyError('invalid explanation')\n        data = data.replace(' ', '').replace('(compute)', '')\n        self.current_exp = data\n\n        if self.explanations[self.current_exp] is None:\n            exp_method = ExplanationMethod.explain_method_as_int(self.current_exp)\n            progress_bar = self.get_progress_bar()\n            self.compute_explanation(exp_method, progress_bar)\n\n        self.on_change_callback(self.current_exp_df)\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.current_exp_df","title":"<code>current_exp_df: pd.DataFrame</code>  <code>property</code>","text":"<p>currently selected explanation projected values instance Returns</p>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.has_user_exp","title":"<code>has_user_exp: bool</code>  <code>property</code>","text":"<p>has the user provided an explanation Returns</p>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.__init__","title":"<code>__init__(X, y, model, task_type, on_change_callback, disable_gui, X_exp=None)</code>","text":""},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.__init__--parameters","title":"Parameters","text":"<p>X: original train DataFrame y: target variable model: customer model on_change_callback: callback to notify explanation change X_exp: user provided explanations</p> Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def __init__(self, X: pd.DataFrame, y: pd.Series, model, task_type, on_change_callback: callable,\n             disable_gui: callable, X_exp=None):\n    \"\"\"\n\n    Parameters\n    ----------\n    X: original train DataFrame\n    y: target variable\n    model: customer model\n    on_change_callback: callback to notify explanation change\n    X_exp: user provided explanations\n    \"\"\"\n    self.widget = None\n    self.X = X\n    self.y = y\n    self.model = model\n    self.task_type = task_type\n    self.on_change_callback = on_change_callback\n    self.disable_gui = disable_gui\n    self.initialized = False\n\n    # init dict of explanations\n    self.explanations: dict[str, pd.DataFrame | None] = {\n        exp: None for exp in self.available_exp\n    }\n\n    if X_exp is not None:\n        self.explanations[self.available_exp[0]] = X_exp\n\n    # init selected explanation\n    if X_exp is not None:\n        self.current_exp = self.available_exp[0]\n    else:\n        self.current_exp = self.available_exp[1]\n\n    self.build_widget()\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.compute_explanation","title":"<code>compute_explanation(explanation_method, progress_bar)</code>","text":"<p>compute explanation and refresh widgets (select the new explanation method) Parameters</p> <p>explanation_method: desired explanation progress_bar : progress bar to notify progress to</p>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.compute_explanation--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def compute_explanation(self, explanation_method: int, progress_bar: callable):\n    \"\"\"\n    compute explanation and refresh widgets (select the new explanation method)\n    Parameters\n    ----------\n    explanation_method: desired explanation\n    progress_bar : progress bar to notify progress to\n\n    Returns\n    -------\n\n    \"\"\"\n    self.disable_gui(True)\n    self.current_exp = self.available_exp[explanation_method]\n    # We compute proj for this new PV :\n    x_exp = compute_explanations(self.X, self.model, explanation_method, self.task_type, progress_bar)\n    pd.testing.assert_index_equal(x_exp.columns, self.X.columns)\n\n    # update explanation\n    self.explanations[self.current_exp] = x_exp\n    # refresh front\n    self.update_explanation_select()\n    self.disable_gui(False)\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.disable_selection","title":"<code>disable_selection(is_disabled)</code>","text":"<p>disable widgets Parameters</p> <p>is_disabled = should disable ?</p>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.disable_selection--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def disable_selection(self, is_disabled: bool):\n    \"\"\"\n    disable widgets\n    Parameters\n    ----------\n    is_disabled = should disable ?\n\n    Returns\n    -------\n\n    \"\"\"\n    self.get_explanation_select().disabled = is_disabled\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.explanation_select_changed","title":"<code>explanation_select_changed(widget, event, data)</code>","text":"<p>triggered on selection of new explanation by user explanation has already been computed (the option is enabled in select) Parameters</p> <p>widget event data: explanation name</p>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.explanation_select_changed--returns","title":"Returns","text":"<p>Called when the user chooses another dataframe</p> Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def explanation_select_changed(self, widget, event, data):\n    \"\"\"\n    triggered on selection of new explanation by user\n    explanation has already been computed (the option is enabled in select)\n    Parameters\n    ----------\n    widget\n    event\n    data: explanation name\n\n    Returns\n    -------\n\n    Called when the user chooses another dataframe\n    \"\"\"\n    if not isinstance(data, str):\n        raise KeyError('invalid explanation')\n    data = data.replace(' ', '').replace('(compute)', '')\n    self.current_exp = data\n\n    if self.explanations[self.current_exp] is None:\n        exp_method = ExplanationMethod.explain_method_as_int(self.current_exp)\n        progress_bar = self.get_progress_bar()\n        self.compute_explanation(exp_method, progress_bar)\n\n    self.on_change_callback(self.current_exp_df)\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.get_explanation_select","title":"<code>get_explanation_select()</code>","text":"<p>returns the explanation select menu Returns</p> Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def get_explanation_select(self):\n    \"\"\"\n    returns the explanation select menu\n    Returns\n    -------\n\n    \"\"\"\n    return self.widget.children[0]\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.initialize","title":"<code>initialize(progress_callback)</code>","text":"<p>initialize class (compute explanation if necessary) Parameters</p> <p>progress_callback : callback to notify progress</p>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.initialize--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def initialize(self, progress_callback):\n    \"\"\"\n    initialize class (compute explanation if necessary)\n    Parameters\n    ----------\n    progress_callback : callback to notify progress\n\n    Returns\n    -------\n\n    \"\"\"\n    if not self.has_user_exp:\n        # compute explanation if not provided\n        self.compute_explanation(config.DEFAULT_EXPLANATION_METHOD, progress_callback)\n    # ensure progress is at 100%\n    progress_callback(100, 0)\n    self.initialized = True\n</code></pre>"},{"location":"reference/antakia/gui/explanation_values/#antakia.gui.explanation_values.ExplanationValues.update_explanation_select","title":"<code>update_explanation_select()</code>","text":"<p>refresh explanation select menu Returns</p> Source code in <code>src/antakia/gui/explanation_values.py</code> <pre><code>def update_explanation_select(self):\n    \"\"\"\n    refresh explanation select menu\n    Returns\n    -------\n\n    \"\"\"\n    exp_values = []\n    for exp in self.available_exp:\n        if exp == 'Imported':\n            exp_values.append({\n                \"text\": exp,\n                'disabled': self.explanations[exp] is None\n            })\n        else:\n            exp_values.append({\n                \"text\": exp + (' (compute)' if self.explanations[exp] is None else ''),\n                'disabled': False\n            })\n    self.get_explanation_select().items = exp_values\n    self.get_explanation_select().v_model = self.current_exp\n</code></pre>"},{"location":"reference/antakia/gui/gui/","title":"gui","text":""},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI","title":"<code>GUI</code>","text":"<p>GUI class.</p> <p>The GUI guides the user through the AntakIA process. It stores Xs, Y and the model to explain. It displays a UI (app_graph) and creates various UI objects, in particular two HighDimExplorers resposnible to compute or project values in 2 spaces.</p> <p>The interface is built using ipyvuetify and plotly. It heavily relies on the IPyWidgets framework.</p>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI--instance-attributes","title":"Instance Attributes","text":"<p>X : Pandas DataFrame, the orignal dataset y : Pandas Series, target values model : a model X_exp : a Pandas DataFrame, containing imported explanations variables : a list of Variable selection_ids : a list of a pd.DataFrame indexes, corresponding to the current selected points     IMPORTANT : a dataframe index may differ from the row number vs_hde, es_hde : HighDimExplorer for the VS and ES space vs_rules_wgt, es_rules_wgt : RulesWidget region_set : a list of Region,     a region is a dict : {'num':int, 'rules': list of rules, 'indexes', 'model': str, 'score': str}     if the list of rules is None, the region has been defined with auto-cluster     num start at 1 validated_rules_region, validated_region, validated_sub_model</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>class GUI:\n    \"\"\"\n    GUI class.\n\n    The GUI guides the user through the AntakIA process.\n    It stores Xs, Y and the model to explain.\n    It displays a UI (app_graph) and creates various UI objects, in particular\n    two HighDimExplorers resposnible to compute or project values in 2 spaces.\n\n    The interface is built using ipyvuetify and plotly.\n    It heavily relies on the IPyWidgets framework.\n\n    Instance Attributes\n    ---------------------\n    X : Pandas DataFrame, the orignal dataset\n    y : Pandas Series, target values\n    model : a model\n    X_exp : a Pandas DataFrame, containing imported explanations\n    variables : a list of Variable\n    selection_ids : a list of a pd.DataFrame indexes, corresponding to the current selected points\n        IMPORTANT : a dataframe index may differ from the row number\n    vs_hde, es_hde : HighDimExplorer for the VS and ES space\n    vs_rules_wgt, es_rules_wgt : RulesWidget\n    region_set : a list of Region,\n        a region is a dict : {'num':int, 'rules': list of rules, 'indexes', 'model': str, 'score': str}\n        if the list of rules is None, the region has been defined with auto-cluster\n        num start at 1\n    validated_rules_region, validated_region, validated_sub_model\n\n    \"\"\"\n\n    def __init__(\n            self,\n            X: pd.DataFrame,\n            y: pd.Series,\n            model,\n            variables: DataVariables,\n            X_test: pd.DataFrame,\n            y_test: pd.Series,\n            X_exp: pd.DataFrame | None = None,\n            score: callable | str = \"mse\",\n            problem_category: ProblemCategory = ProblemCategory.regression\n    ):\n        self.tab = 1\n        self.X = X\n        self.X_test = X_test\n        self.y = y\n        self.y_test = y_test\n        self._y_pred = None\n        self.problem_category = problem_category\n        self.model = model\n        self.variables: DataVariables = variables\n        self.score = score\n        # Init value space widgets\n        self.new_selection = False\n        self.selection_mask = boolean_mask(X, True)\n\n        self.pv_bank = ProjectedValueBank(y)\n\n        # star dialog\n        self.topbar = TopBar()\n\n        # first hde\n        self.vs_hde = HighDimExplorer(\n            self.pv_bank,\n            self.selection_changed,\n            'VS'\n        )\n        # then rules\n        self.vs_rules_wgt = RulesWidget(self.X, self.y, self.variables, True, self.new_rules_defined)\n\n        # init Explanation space\n        # first explanation getter/compute\n        self.exp_values = ExplanationValues(\n            self.X,\n            self.y,\n            self.model,\n            problem_category,\n            self.explanation_changed_callback,\n            self.disable_hde,\n            X_exp\n        )\n        # then hde\n        self.es_hde = HighDimExplorer(\n            self.pv_bank,\n            self.selection_changed,\n            'ES'\n        )\n        # finally rules\n        self.es_rules_wgt = RulesWidget(X_exp, self.y, self.variables, False)\n\n        # We set empty rules for now :\n        self.vs_rules_wgt.disable()\n        self.es_rules_wgt.disable()\n\n        # init tabs\n        self.model_explorer = ModelExplorer(self.X)\n\n        self.region_num_for_validated_rules = None  # tab 1 : number of the region created when validating rules\n        self.region_set = ModelRegionSet(self.X, self.y, self.X_test, self.y_test, self.model, self.score)\n        self.substitute_region = None\n        self.substitution_model_training = False  # tab 3 : training flag\n        self.widget = app_widget.get_app_widget()\n        self.splash_widget = splash_widget.get_app_widget()\n        # UI rules :\n        # We disable the selection datatable at startup (bottom of tab 1)\n        get_widget(self.widget, \"4320\").disabled = True\n\n    def show_splash_screen(self):\n        \"\"\"Displays the splash screen and updates it during the first computations.\"\"\"\n\n        # We add both widgets to the current notebook cell and hide them\n        IPython.display.display(self.splash_widget, self.widget)\n        self.widget.hide()\n        self.splash_widget.show()\n\n        exp_progress_bar = ProgressBar(\n            get_widget(self.splash_widget, \"110\"),\n            unactive_color=\"light blue\",\n            reset_at_end=False\n        )\n        dimreduc_progress_bar = MultiStepProgressBar(\n            get_widget(self.splash_widget, \"210\"),\n            steps=2,\n            unactive_color=\"light blue\",\n            reset_at_end=False\n        )\n        # We trigger VS proj computation :\n        get_widget(\n            self.splash_widget, \"220\"\n        ).v_model = f\"{config.DEFAULT_PROJECTION} on {self.X.shape} 1/2\"\n\n        self.vs_hde.initialize(progress_callback=dimreduc_progress_bar.get_update(1), X=self.X)\n\n        # We trigger ES explain computation if needed :\n        if not self.exp_values.has_user_exp:  # No imported explanation values\n            exp_method = ExplanationMethod.explain_method_as_str(config.DEFAULT_EXPLANATION_METHOD)\n            msg = f\"Computing {exp_method} on {self.X.shape}\"\n        else:\n            msg = f\"Imported explained values {self.X.shape}\"\n        self.exp_values.initialize(exp_progress_bar.update)\n        get_widget(self.splash_widget, \"120\").v_model = msg\n\n        # THen we trigger ES proj computation :\n        get_widget(\n            self.splash_widget, \"220\"\n        ).v_model = f\"{config.DEFAULT_PROJECTION} on {self.X.shape} 2/2\"\n        self.es_hde.initialize(\n            progress_callback=dimreduc_progress_bar.get_update(2),\n            X=self.exp_values.current_exp_df\n        )\n        self.es_rules_wgt.update_X(self.exp_values.current_exp_df)\n        self.selection_changed(None, boolean_mask(self.X, True))\n\n        self.init_app()\n\n        self.splash_widget.hide()\n        self.widget.show()\n        self.vs_hde.figure.create_figure()\n        self.es_hde.figure.create_figure()\n        self.select_tab(0)\n        self.disable_hde()\n\n        if metadata.counter == 10:\n            self.topbar.open()\n        metadata.save()\n\n    def init_app(self):\n        \"\"\"\n        Inits and wires the app_widget, and implements UI logic\n        \"\"\"\n\n        # -------------- Dimension Switch --------------\n\n        change_widget(self.widget, '0', self.topbar.widget)\n\n        # -------------- Dimension Switch --------------\n\n        get_widget(self.widget, \"100\").v_model = config.DEFAULT_DIMENSION == 3\n        get_widget(self.widget, \"100\").on_event(\"change\", self.switch_dimension)\n\n        # -------------- ColorChoiceBtnToggle ------------\n\n        # Set \"change\" event on the Button Toggle used to chose color\n        get_widget(self.widget, \"11\").on_event(\"change\", self.change_color)\n\n        # -------------- ExplanationSelect ------------\n\n        get_widget(self.widget, '12').children = [self.exp_values.widget]\n\n        # -------------- set up VS High Dim Explorer  ------------\n\n        get_widget(self.widget, '13').children = [self.vs_hde.projected_value_selector.widget]\n        change_widget(self.widget, \"201\", self.vs_hde.figure.widget),\n\n        # -------------- set up ES High Dim Explorer ------------\n\n        get_widget(self.widget, '14').children = [self.es_hde.projected_value_selector.widget]\n        change_widget(self.widget, \"211\", self.es_hde.figure.widget),\n\n        # ================ Tab 1 Selection ================\n\n        # We wire the click event on 'Tab 1'\n        get_widget(self.widget, \"40\").on_event(\"click\", self.select_tab_front(1))\n\n        # We add our 2 RulesWidgets to the GUI :\n        change_widget(self.widget, \"4310\", self.vs_rules_wgt.root_widget)\n        change_widget(self.widget, \"4311\", self.es_rules_wgt.root_widget)\n\n        # We wire the click event on the 'Find-rules' button\n        get_widget(self.widget, \"43010\").on_event(\"click\", self.compute_skope_rules)\n\n        # We wire the ckick event on the 'Undo' button\n        get_widget(self.widget, \"4302\").on_event(\"click\", self.undo_rules)\n\n        # Its enabled when rules graphs have been updated with rules\n        # We wire the click event on the 'Valildate rules' button\n        get_widget(self.widget, \"43030\").on_event(\"click\", self.validate_rules)\n\n        # It's enabled when a SKR rules has been found and is disabled when the selection gets empty\n        # or when validated is pressed\n\n        # ================ Tab 2 : regions ===============\n        # We wire the click event on 'Tab 2'\n        get_widget(self.widget, \"41\").on_event(\"click\", self.select_tab_front(2))\n\n        get_widget(self.widget, \"44001\").set_callback(self.region_selected)\n\n        # We wire events on the 'substitute' button:\n        get_widget(self.widget, \"4401000\").on_event(\"click\", self.substitute_clicked)\n        # button is disabled by default\n        get_widget(self.widget, \"4401000\").disabled = True\n\n        # We wire events on the 'divide' button:\n        get_widget(self.widget, \"4401100\").on_event(\"click\", self.divide_region_clicked)\n        # button is disabled by default\n        get_widget(self.widget, \"4401100\").disabled = True\n\n        # We wire events on the 'merge' button:\n        get_widget(self.widget, \"4401200\").on_event(\"click\", self.merge_region_clicked)\n        # button is disabled by default\n        get_widget(self.widget, \"4401200\").disabled = True\n\n        # We wire events on the 'delete' button:\n        get_widget(self.widget, \"4401300\").on_event(\"click\", self.delete_region_clicked)\n        # The 'delete' button is disabled at startup\n        get_widget(self.widget, \"4401300\").disabled = True\n\n        # We wire events on the 'auto-cluster' button :\n        get_widget(self.widget, \"4402000\").on_event(\"click\", self.auto_cluster_clicked)\n\n        # UI rules :\n        # The 'auto-cluster' button is disabled at startup\n        get_widget(self.widget, \"4402000\").disabled = True\n        # Checkbox automatic number of cluster is set to True at startup\n        get_widget(self.widget, \"440211\").v_model = True\n\n        # We wire select events on this checkbox :\n        get_widget(self.widget, \"440211\").on_event(\"change\", self.checkbox_auto_cluster_clicked)\n\n        def num_cluster_changed(*args):\n            \"\"\"\n            Called when the user changes the number of clusters\n            \"\"\"\n            # We enable the 'auto-cluster' button\n            get_widget(self.widget, \"4402000\").disabled = False\n\n        # We wire events on the num cluster Slider\n        get_widget(self.widget, \"4402100\").on_event(\"change\", num_cluster_changed)\n\n        # UI rules : at startup, the slider is disabled and the checkbox is checked\n        get_widget(self.widget, \"4402100\").disabled = True\n\n        self.update_region_table()\n        # At startup, REGIONSET_TRACE is not visible\n\n        # ============== Tab 3 : substitution ==================\n\n        # We wire the click event on 'Tab 3'\n        get_widget(self.widget, \"42\").on_event(\"click\", self.select_tab_front(3))\n\n        # UI rules :\n        # At startup validate sub-model btn is disabled :\n        get_widget(self.widget, \"4501000\").disabled = True\n\n        # We wire a select event on the 'substitution table' :\n        get_widget(self.widget, \"45001\").set_callback(self.sub_model_selected_callback)\n\n        # We wire a ckick event on the \"validate sub-model\" button :\n        get_widget(self.widget, \"4501000\").on_event(\"click\", self.validate_sub_model)\n        get_widget(self.widget, \"4502\").children = [self.model_explorer.widget]\n\n        # We disable the Substitution table at startup :\n        self.update_substitution_table(None)\n\n        self.refresh_buttons_tab_1()\n\n    # ==================== properties ==================== #\n\n    @property\n    def selected_regions(self):\n        return get_widget(self.widget, \"44001\").selected\n\n    @selected_regions.setter\n    def selected_regions(self, value):\n        get_widget(self.widget, \"44001\").selected = value\n        self.disable_buttons(None)\n\n    @property\n    def selected_sub_model(self):\n        return get_widget(self.widget, \"45001\").selected\n\n    @selected_sub_model.setter\n    def selected_sub_model(self, value):\n        get_widget(self.widget, \"45001\").selected = value\n\n    @property\n    def y_pred(self):\n        if self._y_pred is None:\n            pred = self.model.predict(self.X)\n            if self.problem_category in [ProblemCategory.classification_with_proba]:\n                pred = self.model.predict_proba(self.X)\n\n            if len(pred.shape) &gt; 1:\n                if pred.shape[1] == 1:\n                    pred = pred.squeeze()\n                if pred.shape[1] == 2:\n                    pred = np.array(pred)[:, 1]\n                else:\n                    pred = pred.argmax(axis=1)\n            self._y_pred = pd.Series(pred, index=self.X.index)\n        return self._y_pred\n\n    # ==================== sync callbacks ==================== #\n\n    def explanation_changed_callback(self, current_exp_df: pd.DataFrame, progress_callback: callable = None):\n        self.es_hde.update_X(current_exp_df, progress_callback)\n        self.es_rules_wgt.update_X(current_exp_df)\n\n    def disable_hde(self, disable='auto'):\n        if disable == 'auto':\n            disable_proj = bool((self.tab == 0) and self.selection_mask.any() and not self.selection_mask.all())\n            disable_figure = bool(self.tab &gt; 1)\n        else:\n            disable_proj = disable\n            disable_figure = disable\n        self.vs_hde.disable(disable_figure, disable_proj)\n        self.exp_values.disable_selection(disable_proj)\n        self.es_hde.disable(disable_figure, disable_proj)\n\n    def selection_changed(self, caller: HighDimExplorer | None, new_selection_mask: pd.Series):\n        \"\"\"Called when the selection of one HighDimExplorer changes\"\"\"\n\n        # UI rules :\n        # If new selection (empty or not) : if exists, we remove any 'pending rule'\n        self.new_selection = True\n        self.disable_hde()\n        if new_selection_mask.all():\n            # Selection is empty\n            # we display y as color\n            self.select_tab(0)\n            # we reset rules_widgets\n            self.vs_rules_wgt.disable()\n            self.es_rules_wgt.disable()\n            self.es_rules_wgt.reset_widget()\n            self.vs_rules_wgt.reset_widget()\n        else:\n            # Selection is not empty anymore or changes\n            X_rounded = copy.copy((self.X.loc[new_selection_mask])).round(3)\n            change_widget(\n                self.widget,\n                \"432010\",\n                v.DataTable(\n                    v_model=[],\n                    show_select=False,\n                    headers=[{\"text\": column, \"sortable\": True, \"value\": column} for column in self.X.columns],\n                    items=X_rounded.to_dict(\"records\"),\n                    hide_default_footer=False,\n                    disable_sort=False,\n                ),\n            )\n\n        # We store the new selection\n        self.selection_mask = new_selection_mask\n        # We synchronize selection between the two HighDimExplorers\n        if caller is None:\n            self.es_hde.set_selection(self.selection_mask)\n            self.vs_hde.set_selection(self.selection_mask)\n        else:\n            other_hde = self.es_hde if caller == self.vs_hde.figure else self.vs_hde\n            other_hde.set_selection(self.selection_mask)\n\n        # We update the selection status :\n        if not self.selection_mask.all():\n            selection_status_str_1 = f\"{self.selection_mask.sum()} point selected\"\n            selection_status_str_2 = f\"{100 * self.selection_mask.mean():.2f}% of the  dataset\"\n        else:\n            selection_status_str_1 = f\"0 point selected\"\n            selection_status_str_2 = f\"0% of the  dataset\"\n        change_widget(self.widget, \"4300000\", selection_status_str_1)\n        change_widget(self.widget, \"430010\", selection_status_str_2)\n        # we refresh button and enable/disable the datatable\n        self.refresh_buttons_tab_1()\n\n    def new_rules_defined(self, rules_widget: RulesWidget, df_mask: pd.Series):\n        \"\"\"\n        Called by a RulesWidget Skope rule creation or when the user wants new rules to be plotted\n        The function asks the HDEs to display the rules result\n        \"\"\"\n        # We sent to the proper HDE the rules_indexes to render :\n        self.vs_hde.figure.display_rules(selection_mask=self.selection_mask, rules_mask=df_mask)\n        self.es_hde.figure.display_rules(selection_mask=self.selection_mask, rules_mask=df_mask)\n\n        # sync selection between rules_widgets\n        if rules_widget == self.vs_rules_wgt:\n            self.es_rules_wgt.update_from_mask(df_mask, RuleSet(), sync=False)\n        else:\n            self.vs_rules_wgt.update_from_mask(df_mask, RuleSet(), sync=False)\n\n        self.refresh_buttons_tab_1()\n\n    # ==================== top bar ==================== #\n\n    def set_dimension(self, dim):\n        get_widget(self.widget, \"100\").v_model = dim == 3\n        self.vs_hde.set_dim(dim)\n        self.es_hde.set_dim(dim)\n\n    def switch_dimension(self, widget, event, data):\n        \"\"\"\n        Called when the switch changes.\n        We call the HighDimExplorer to update its figure and, enventually,\n        compute its proj\n        \"\"\"\n        self.set_dimension(3 if data else 2)\n\n    def change_color(self, widget, event, data):\n        \"\"\"\n        Called with the user clicks on the colorChoiceBtnToggle\n        Allows change the color of the dots\n        \"\"\"\n\n        # Color : a pd.Series with one color value par row\n        color = None\n\n        if data == \"y\":\n            color = self.y\n        elif data == \"y^\":\n            color = self.y_pred\n        elif data == \"residual\":\n            color = self.y - self.y_pred\n\n        self.vs_hde.figure.set_color(color, 0)\n        self.es_hde.figure.set_color(color, 0)\n        self.select_tab(0)\n\n    # ==================== TAB handling ==================== #\n\n    def select_tab_front(self, tab):\n        def call_fct(*args):\n            self.select_tab(tab, front=True)\n\n        return call_fct\n\n    def select_tab(self, tab, front=False):\n        if tab == 1 and (not self.selection_mask.any() or self.selection_mask.all()):\n            return self.select_tab(0)\n        if tab == 1:\n            self.vs_hde.figure.display_selection()\n            self.es_hde.figure.display_selection()\n        elif tab == 2:\n            self.update_region_table()\n            self.vs_hde.figure.display_regionset(self.region_set)\n            self.es_hde.figure.display_regionset(self.region_set)\n        elif tab == 3:\n            if len(self.selected_regions) == 0:\n                self.select_tab(2)\n            else:\n                region = self.region_set.get(self.selected_regions[0]['Region'])\n                self.update_substitution_table(region)\n                if region is None:\n                    region = ModelRegion(self.X, self.y, self.X_test, self.y_test, self.model, score=self.score)\n                self.vs_hde.figure.display_region(region)\n                self.es_hde.figure.display_region(region)\n        if not front:\n            get_widget(self.widget, \"4\").v_model = max(tab - 1, 0)\n        self.vs_hde.set_tab(tab)\n        self.es_hde.set_tab(tab)\n        self.tab = tab\n        self.disable_hde()\n\n    # ==================== TAB 1 ==================== #\n\n    def refresh_buttons_tab_1(self):\n        self.disable_hde()\n        # data table\n        get_widget(self.widget, \"4320\").disabled = bool(self.selection_mask.all())\n        # skope_rule\n        get_widget(self.widget, \"43010\").disabled = not self.new_selection or bool(self.selection_mask.all())\n        # undo\n        get_widget(self.widget, \"4302\").disabled = not (self.vs_rules_wgt.rules_num &gt; 1)\n        # validate rule\n        get_widget(self.widget, \"43030\").disabled = not (self.vs_rules_wgt.rules_num &gt; 0)\n\n    def compute_skope_rules(self, *args):\n        self.new_selection = False\n\n        if self.tab != 1:\n            self.select_tab(1)\n        # compute skope rules\n        skr_rules_list, skr_score_dict = skope_rules(self.selection_mask, self.vs_hde.current_X, self.variables)\n        skr_score_dict['target_avg'] = self.y[self.selection_mask].mean()\n        # init vs rules widget\n        self.vs_rules_wgt.init_rules(skr_rules_list, skr_score_dict, self.selection_mask)\n        # update VS and ES HDE\n        self.vs_hde.figure.display_rules(\n            selection_mask=self.selection_mask,\n            rules_mask=skr_rules_list.get_matching_mask(self.X)\n        )\n        self.es_hde.figure.display_rules(\n            selection_mask=self.selection_mask,\n            rules_mask=skr_rules_list.get_matching_mask(self.X)\n        )\n\n        es_skr_rules_list, es_skr_score_dict = skope_rules(self.selection_mask, self.es_hde.current_X, self.variables)\n        es_skr_score_dict['target_avg'] = self.y[self.selection_mask].mean()\n        self.es_rules_wgt.init_rules(es_skr_rules_list, es_skr_score_dict, self.selection_mask)\n        self.refresh_buttons_tab_1()\n        self.select_tab(1)\n\n    def undo_rules(self, *args):\n        if self.tab != 1:\n            self.select_tab(1)\n        if self.vs_rules_wgt.rules_num &gt; 0:\n            self.vs_rules_wgt.undo()\n        else:\n            # TODO : pourquoi on annule d'abord le VS puis l'ES?\n            self.es_rules_wgt.undo()\n        self.refresh_buttons_tab_1()\n\n    def validate_rules(self, *args):\n        if self.tab != 1:\n            self.select_tab(1)\n\n        rules_list = self.vs_rules_wgt.current_rules_list\n        # UI rules :\n        # We clear selection\n        self.selection_changed(None, boolean_mask(self.X, True))\n        # We clear the RulesWidget\n        self.es_rules_wgt.reset_widget()\n        self.vs_rules_wgt.reset_widget()\n        if len(rules_list) == 0:\n            self.vs_rules_wgt.show_msg(\"No rules found on Value space cannot validate region\", \"red--text\")\n            return\n\n        # We add them to our region_set\n        region = self.region_set.add_region(rules=rules_list)\n        self.region_num_for_validated_rules = region.num\n        # lock rule\n        region.validate()\n\n        # And update the rules table (tab 2)\n        # we refresh buttons\n        self.refresh_buttons_tab_1()\n        # We force tab 2\n        self.select_tab(2)\n\n    # ==================== TAB 2 ==================== #\n\n    def update_region_table(self):\n        \"\"\"\n        Called to empty / fill the RegionDataTable and refresh plots\n        \"\"\"\n        self.region_set.sort(by='size', ascending=False)\n        temp_items = self.region_set.to_dict()\n\n        # We populate the ColorTable :\n        get_widget(self.widget, \"44001\").items = temp_items\n\n        region_stats = self.region_set.stats()\n        str_stats = [\n            f\"{region_stats['regions']} {'regions' if region_stats['regions'] &gt; 1 else 'region'}\",\n            f\"{region_stats['points']} points\",\n            f\"{region_stats['coverage']}% of the dataset\",\n            f\"{region_stats['delta_score']:.2f} subst score\"\n        ]\n        get_widget(self.widget, \"44002\").children = [\n            ', '.join(str_stats)\n        ]\n        get_widget(self.widget, \"4402000\").disabled = False\n\n    def checkbox_auto_cluster_clicked(self, widget, event, data):\n        \"\"\"\n        Called when the user clicks on the 'auto-cluster' checkbox\n        \"\"\"\n        if self.tab != 2:\n            self.select_tab(2)\n        # In any case, we enable the auto-cluster button\n        get_widget(self.widget, \"4402000\").disabled = False\n\n        # We reveive either True or {} (bool({})==False))\n        data = bool(data)\n\n        # IF true, we disable the Slider\n        get_widget(self.widget, \"4402100\").disabled = data\n\n    def auto_cluster_clicked(self, *args):\n        \"\"\"\n        Called when the user clicks on the 'auto-cluster' button\n        \"\"\"\n        # We disable the AC button. Il will be re-enabled when the AC progress is 100%\n        get_widget(self.widget, \"4402000\").disabled = True\n        if self.tab != 2:\n            self.select_tab(2)\n        if self.region_set.stats()[\"coverage\"] &gt; 80:\n            # UI rules :\n            # region_set coverage is &gt; 80% : we need to clear it to do another auto-cluster\n            self.region_set.clear_unvalidated()\n\n        # We assemble indices ot all existing regions :\n        region_set_mask = self.region_set.mask\n        not_rules_indexes_list = ~region_set_mask\n        # We call the auto_cluster with remaining X and explained(X) :\n        if get_widget(self.widget, \"440211\").v_model:\n            cluster_num = \"auto\"\n        else:\n            cluster_num = get_widget(self.widget, \"4402100\").v_model - len(self.region_set)\n            if cluster_num &lt;= 2:\n                cluster_num = 2\n\n        self.compute_auto_cluster(not_rules_indexes_list, cluster_num)\n\n        # We re-enable the button\n        get_widget(self.widget, \"4402000\").disabled = False\n        self.select_tab(2)\n\n    def compute_auto_cluster(self, not_rules_indexes_list, cluster_num='auto'):\n        if len(not_rules_indexes_list) &gt; config.MIN_POINTS_NUMBER:\n            vs_compute = int(not self.vs_hde.projected_value_selector.is_computed(dim=3))\n            es_compute = int(not self.es_hde.projected_value_selector.is_computed(dim=3))\n            steps = 1 + vs_compute + es_compute\n\n            progress_bar = MultiStepProgressBar(get_widget(self.widget, \"440212\"), steps=steps)\n            step = 1\n            vs_proj_3d_df = self.vs_hde.get_current_X_proj(\n                3,\n                progress_callback=progress_bar.get_update(step)\n            )\n\n            step += vs_compute\n            es_proj_3d_df = self.es_hde.get_current_X_proj(\n                3,\n                progress_callback=progress_bar.get_update(step)\n            )\n\n            step += es_compute\n            ac = AutoCluster(self.X, progress_bar.get_update(step))\n\n            found_regions = ac.compute(\n                vs_proj_3d_df.loc[not_rules_indexes_list],\n                es_proj_3d_df.loc[not_rules_indexes_list],\n                # We send 'auto' or we read the number of clusters from the Slider\n                cluster_num,\n            )  # type: ignore\n            self.region_set.extend(found_regions)\n            progress_bar.set_progress(100)\n        else:\n            print('not enough points to cluster')\n\n    def disable_buttons(self, current_operation):\n        selected_region_nums = [x['Region'] for x in self.selected_regions]\n        if current_operation:\n            if current_operation['type'] == 'select':\n                selected_region_nums.append(current_operation['region_num'])\n            elif current_operation['type'] == 'unselect':\n                selected_region_nums.remove(current_operation['region_num'])\n        num_selected_regions = len(selected_region_nums)\n        if num_selected_regions:\n            first_region = self.region_set.get(selected_region_nums[0])\n            enable_div = (num_selected_regions == 1) and bool(first_region.num_points() &gt;= config.MIN_POINTS_NUMBER)\n        else:\n            enable_div = False\n\n        # substitute\n        get_widget(self.widget, \"4401000\").disabled = num_selected_regions != 1\n\n        # divide\n        get_widget(self.widget, \"4401100\").disabled = not enable_div\n\n        # merge\n        enable_merge = (num_selected_regions &gt; 1)\n        get_widget(self.widget, \"4401200\").disabled = not enable_merge\n\n        # delete\n        get_widget(self.widget, \"4401300\").disabled = num_selected_regions == 0\n\n    def region_selected(self, data):\n        if self.tab != 2:\n            self.select_tab(2)\n        operation = {\n            'type': 'select' if data['value'] else 'unselect',\n            'region_num': data['item']['Region']\n        }\n        self.disable_buttons(operation)\n\n    def clear_selected_regions(self):\n        self.selected_regions = []\n        self.disable_buttons(None)\n\n    def divide_region_clicked(self, *args):\n        \"\"\"\n        Called when the user clicks on the 'divide' (region) button\n        \"\"\"\n        if self.tab != 2:\n            self.select_tab(2)\n        # we recover the region to sudivide\n        region = self.region_set.get(self.selected_regions[0]['Region'])\n        if region.num_points() &gt; config.MIN_POINTS_NUMBER:\n            # Then we delete the region in self.region_set\n            self.region_set.remove(region.num)\n            # we compute the subregions and add them to the region set\n            if get_widget(self.widget, \"440211\").v_model:\n                cluster_num = \"auto\"\n            else:\n                cluster_num = get_widget(self.widget, \"4402100\").v_model - len(self.region_set)\n                if cluster_num &lt;= 2:\n                    cluster_num = 2\n            self.compute_auto_cluster(region.mask, cluster_num)\n        self.select_tab(2)\n        # There is no more selected region\n        self.clear_selected_regions()\n\n    def merge_region_clicked(self, *args):\n        \"\"\"\n        Called when the user clicks on the 'merge' (regions) button\n        \"\"\"\n\n        selected_regions = [self.region_set.get(r['Region']) for r in self.selected_regions]\n        mask = None\n        for region in selected_regions:\n            if mask is None:\n                mask = region.mask\n            else:\n                mask |= region.mask\n\n        # compute skope rules\n        skr_rules_list, _ = skope_rules(mask, self.vs_hde.current_X, self.variables)\n\n        # delete regions\n        for region in selected_regions:\n            self.region_set.remove(region.num)\n        # add new region\n        if len(skr_rules_list) &gt; 0:\n            r = self.region_set.add_region(rules=skr_rules_list)\n        else:\n            r = self.region_set.add_region(mask=mask)\n        self.selected_regions = [{'Region': r.num}]\n        self.select_tab(2)\n\n    def delete_region_clicked(self, *args):\n        \"\"\"\n        Called when the user clicks on the 'delete' (region) button\n        \"\"\"\n        if self.tab != 2:\n            self.select_tab(2)\n        for selected_region in self.selected_regions:\n            region = self.region_set.get(selected_region['Region'])\n            # Then we delete the regions in self.region_set\n            self.region_set.remove(region.num)\n\n        self.select_tab(2)\n        # There is no more selected region\n        self.clear_selected_regions()\n\n    # ==================== TAB 3 ==================== #\n\n    def substitute_clicked(self, widget, event, data):\n        region = self.region_set.get(self.selected_regions[0]['Region'])\n        self.selected_sub_model = []\n        if region is not None:\n            # We update the substitution table once to show the name of the region\n            self.substitution_model_training = True\n            # show tab 3 (and update)\n            self.select_tab(3)\n            region.train_substitution_models(task_type=self.problem_category)\n\n            self.substitution_model_training = False\n            # We update the substitution table a second time to show the results\n            self.update_substitution_table(region)\n\n    def update_subtitution_prefix(self, region):\n        # Region prefix text\n        get_widget(self.widget, \"450000\").class_ = \"mr-2 black--text\" if region else \"mr-2 grey--text\"\n        # v.Chip\n        get_widget(self.widget, \"450001\").color = region.color if region else \"grey\"\n        get_widget(self.widget, \"450001\").children = [str(region.num)] if region else [\"-\"]\n\n    def update_subtitution_progress_bar(self):\n        prog_circular = get_widget(self.widget, \"450110\")\n        if self.substitution_model_training:\n            prog_circular.disabled = False\n            prog_circular.color = \"blue\"\n            prog_circular.indeterminate = True\n        else:\n            prog_circular.disabled = True\n            prog_circular.color = \"grey\"\n            prog_circular.indeterminate = False\n\n    def update_substitution_title(self, region: ModelRegion):\n        title = get_widget(self.widget, \"450002\")\n        title.tag = \"h3\"\n        table = get_widget(self.widget, \"45001\")  # subModel table\n        if self.substitution_model_training:\n            # We tell to wait ...\n            title.class_ = \"ml-2 grey--text italic \"\n            title.children = [f\"Sub-models are being evaluated ...\"]\n            # We clear items int the SubModelTable\n            table.items = []\n        elif not region:  # no region provided\n            title.class_ = \"ml-2 grey--text italic \"\n            title.children = [f\"No region selected for substitution\"]\n            table.items = []\n        elif region.num_points() &lt; config.MIN_POINTS_NUMBER:  # region is too small\n            title.class_ = \"ml-2 red--text\"\n            title.children = [\" Region too small for substitution !\"]\n            table.items = []\n        elif len(region.perfs) == 0:  # model not trained\n            title.class_ = \"ml-2 red--text\"\n            title.children = [\" click on substitute button to train substitution models\"]\n            table.items = []\n        else:\n            # We have results\n            title.class_ = \"ml-2 black--text\"\n            title.children = [\n                f\"{region.name}, \"\n                f\"{region.num_points()} points, {100 * region.dataset_cov():.1f}% of the dataset\"\n            ]\n\n            def series_to_str(series: pd.Series) -&gt; str:\n                return series.apply(lambda x: f\"{x:.2f}\")\n\n            perfs = region.perfs.copy()\n            for col in perfs.columns:\n                if col != 'delta_color':\n                    perfs[col] = series_to_str(perfs[col])\n            perfs = perfs.reset_index().rename(columns={\"index\": \"Sub-model\"})\n            headers = [\n                {\n                    \"text\": column,\n                    \"sortable\": False,\n                    \"value\": column,\n                }\n                for column in perfs.drop('delta_color', axis=1).columns\n            ]\n            table.headers = headers\n            table.items = perfs.to_dict(\"records\")\n            if region.interpretable_models.selected_model:\n                # we set to selected model if any\n                table.selected = [{'Sub-model': region.interpretable_models.selected_model}]\n                self.model_explorer.update_selected_model(region.get_selected_model(), region)\n            else:\n                # clear selection if new region:\n                self.model_explorer.reset()\n                table.selected = []\n\n    def update_substitution_table(self, region: ModelRegion | None):\n        \"\"\"\n        Called twice to update table\n        \"\"\"\n        # set region to called region\n        self.substitute_region = region\n\n        self.update_subtitution_prefix(region)\n        self.update_subtitution_progress_bar()\n        self.update_substitution_title(region)\n\n    def sub_model_selected_callback(self, data):\n        is_selected = bool(data[\"value\"])\n        # We use this GUI attribute to store the selected sub-model\n        self.selected_sub_model = [data['item']]\n        get_widget(self.widget, \"4501000\").disabled = not is_selected\n        if is_selected:\n            region = self.region_set.get(self.selected_regions[0]['Region'])\n            self.model_explorer.update_selected_model(region.get_model(data['item']['Sub-model']), region)\n        else:\n            self.model_explorer.reset()\n\n    def validate_sub_model(self, *args):\n        # We get the sub-model data from the SubModelTable:\n        # get_widget(self.widget,\"45001\").items[self.validated_sub_model]\n\n        get_widget(self.widget, \"4501000\").disabled = True\n\n        # We udpate the region\n        region = self.region_set.get(self.selected_regions[0]['Region'])\n        region.select_model(self.selected_sub_model[0]['Sub-model'])\n        region.validate()\n        # empty selected region\n        self.selected_regions = []\n        self.selected_sub_model = []\n        # Show tab 2\n        self.select_tab(2)\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.auto_cluster_clicked","title":"<code>auto_cluster_clicked(*args)</code>","text":"<p>Called when the user clicks on the 'auto-cluster' button</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def auto_cluster_clicked(self, *args):\n    \"\"\"\n    Called when the user clicks on the 'auto-cluster' button\n    \"\"\"\n    # We disable the AC button. Il will be re-enabled when the AC progress is 100%\n    get_widget(self.widget, \"4402000\").disabled = True\n    if self.tab != 2:\n        self.select_tab(2)\n    if self.region_set.stats()[\"coverage\"] &gt; 80:\n        # UI rules :\n        # region_set coverage is &gt; 80% : we need to clear it to do another auto-cluster\n        self.region_set.clear_unvalidated()\n\n    # We assemble indices ot all existing regions :\n    region_set_mask = self.region_set.mask\n    not_rules_indexes_list = ~region_set_mask\n    # We call the auto_cluster with remaining X and explained(X) :\n    if get_widget(self.widget, \"440211\").v_model:\n        cluster_num = \"auto\"\n    else:\n        cluster_num = get_widget(self.widget, \"4402100\").v_model - len(self.region_set)\n        if cluster_num &lt;= 2:\n            cluster_num = 2\n\n    self.compute_auto_cluster(not_rules_indexes_list, cluster_num)\n\n    # We re-enable the button\n    get_widget(self.widget, \"4402000\").disabled = False\n    self.select_tab(2)\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.change_color","title":"<code>change_color(widget, event, data)</code>","text":"<p>Called with the user clicks on the colorChoiceBtnToggle Allows change the color of the dots</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def change_color(self, widget, event, data):\n    \"\"\"\n    Called with the user clicks on the colorChoiceBtnToggle\n    Allows change the color of the dots\n    \"\"\"\n\n    # Color : a pd.Series with one color value par row\n    color = None\n\n    if data == \"y\":\n        color = self.y\n    elif data == \"y^\":\n        color = self.y_pred\n    elif data == \"residual\":\n        color = self.y - self.y_pred\n\n    self.vs_hde.figure.set_color(color, 0)\n    self.es_hde.figure.set_color(color, 0)\n    self.select_tab(0)\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.checkbox_auto_cluster_clicked","title":"<code>checkbox_auto_cluster_clicked(widget, event, data)</code>","text":"<p>Called when the user clicks on the 'auto-cluster' checkbox</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def checkbox_auto_cluster_clicked(self, widget, event, data):\n    \"\"\"\n    Called when the user clicks on the 'auto-cluster' checkbox\n    \"\"\"\n    if self.tab != 2:\n        self.select_tab(2)\n    # In any case, we enable the auto-cluster button\n    get_widget(self.widget, \"4402000\").disabled = False\n\n    # We reveive either True or {} (bool({})==False))\n    data = bool(data)\n\n    # IF true, we disable the Slider\n    get_widget(self.widget, \"4402100\").disabled = data\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.delete_region_clicked","title":"<code>delete_region_clicked(*args)</code>","text":"<p>Called when the user clicks on the 'delete' (region) button</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def delete_region_clicked(self, *args):\n    \"\"\"\n    Called when the user clicks on the 'delete' (region) button\n    \"\"\"\n    if self.tab != 2:\n        self.select_tab(2)\n    for selected_region in self.selected_regions:\n        region = self.region_set.get(selected_region['Region'])\n        # Then we delete the regions in self.region_set\n        self.region_set.remove(region.num)\n\n    self.select_tab(2)\n    # There is no more selected region\n    self.clear_selected_regions()\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.divide_region_clicked","title":"<code>divide_region_clicked(*args)</code>","text":"<p>Called when the user clicks on the 'divide' (region) button</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def divide_region_clicked(self, *args):\n    \"\"\"\n    Called when the user clicks on the 'divide' (region) button\n    \"\"\"\n    if self.tab != 2:\n        self.select_tab(2)\n    # we recover the region to sudivide\n    region = self.region_set.get(self.selected_regions[0]['Region'])\n    if region.num_points() &gt; config.MIN_POINTS_NUMBER:\n        # Then we delete the region in self.region_set\n        self.region_set.remove(region.num)\n        # we compute the subregions and add them to the region set\n        if get_widget(self.widget, \"440211\").v_model:\n            cluster_num = \"auto\"\n        else:\n            cluster_num = get_widget(self.widget, \"4402100\").v_model - len(self.region_set)\n            if cluster_num &lt;= 2:\n                cluster_num = 2\n        self.compute_auto_cluster(region.mask, cluster_num)\n    self.select_tab(2)\n    # There is no more selected region\n    self.clear_selected_regions()\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.init_app","title":"<code>init_app()</code>","text":"<p>Inits and wires the app_widget, and implements UI logic</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def init_app(self):\n    \"\"\"\n    Inits and wires the app_widget, and implements UI logic\n    \"\"\"\n\n    # -------------- Dimension Switch --------------\n\n    change_widget(self.widget, '0', self.topbar.widget)\n\n    # -------------- Dimension Switch --------------\n\n    get_widget(self.widget, \"100\").v_model = config.DEFAULT_DIMENSION == 3\n    get_widget(self.widget, \"100\").on_event(\"change\", self.switch_dimension)\n\n    # -------------- ColorChoiceBtnToggle ------------\n\n    # Set \"change\" event on the Button Toggle used to chose color\n    get_widget(self.widget, \"11\").on_event(\"change\", self.change_color)\n\n    # -------------- ExplanationSelect ------------\n\n    get_widget(self.widget, '12').children = [self.exp_values.widget]\n\n    # -------------- set up VS High Dim Explorer  ------------\n\n    get_widget(self.widget, '13').children = [self.vs_hde.projected_value_selector.widget]\n    change_widget(self.widget, \"201\", self.vs_hde.figure.widget),\n\n    # -------------- set up ES High Dim Explorer ------------\n\n    get_widget(self.widget, '14').children = [self.es_hde.projected_value_selector.widget]\n    change_widget(self.widget, \"211\", self.es_hde.figure.widget),\n\n    # ================ Tab 1 Selection ================\n\n    # We wire the click event on 'Tab 1'\n    get_widget(self.widget, \"40\").on_event(\"click\", self.select_tab_front(1))\n\n    # We add our 2 RulesWidgets to the GUI :\n    change_widget(self.widget, \"4310\", self.vs_rules_wgt.root_widget)\n    change_widget(self.widget, \"4311\", self.es_rules_wgt.root_widget)\n\n    # We wire the click event on the 'Find-rules' button\n    get_widget(self.widget, \"43010\").on_event(\"click\", self.compute_skope_rules)\n\n    # We wire the ckick event on the 'Undo' button\n    get_widget(self.widget, \"4302\").on_event(\"click\", self.undo_rules)\n\n    # Its enabled when rules graphs have been updated with rules\n    # We wire the click event on the 'Valildate rules' button\n    get_widget(self.widget, \"43030\").on_event(\"click\", self.validate_rules)\n\n    # It's enabled when a SKR rules has been found and is disabled when the selection gets empty\n    # or when validated is pressed\n\n    # ================ Tab 2 : regions ===============\n    # We wire the click event on 'Tab 2'\n    get_widget(self.widget, \"41\").on_event(\"click\", self.select_tab_front(2))\n\n    get_widget(self.widget, \"44001\").set_callback(self.region_selected)\n\n    # We wire events on the 'substitute' button:\n    get_widget(self.widget, \"4401000\").on_event(\"click\", self.substitute_clicked)\n    # button is disabled by default\n    get_widget(self.widget, \"4401000\").disabled = True\n\n    # We wire events on the 'divide' button:\n    get_widget(self.widget, \"4401100\").on_event(\"click\", self.divide_region_clicked)\n    # button is disabled by default\n    get_widget(self.widget, \"4401100\").disabled = True\n\n    # We wire events on the 'merge' button:\n    get_widget(self.widget, \"4401200\").on_event(\"click\", self.merge_region_clicked)\n    # button is disabled by default\n    get_widget(self.widget, \"4401200\").disabled = True\n\n    # We wire events on the 'delete' button:\n    get_widget(self.widget, \"4401300\").on_event(\"click\", self.delete_region_clicked)\n    # The 'delete' button is disabled at startup\n    get_widget(self.widget, \"4401300\").disabled = True\n\n    # We wire events on the 'auto-cluster' button :\n    get_widget(self.widget, \"4402000\").on_event(\"click\", self.auto_cluster_clicked)\n\n    # UI rules :\n    # The 'auto-cluster' button is disabled at startup\n    get_widget(self.widget, \"4402000\").disabled = True\n    # Checkbox automatic number of cluster is set to True at startup\n    get_widget(self.widget, \"440211\").v_model = True\n\n    # We wire select events on this checkbox :\n    get_widget(self.widget, \"440211\").on_event(\"change\", self.checkbox_auto_cluster_clicked)\n\n    def num_cluster_changed(*args):\n        \"\"\"\n        Called when the user changes the number of clusters\n        \"\"\"\n        # We enable the 'auto-cluster' button\n        get_widget(self.widget, \"4402000\").disabled = False\n\n    # We wire events on the num cluster Slider\n    get_widget(self.widget, \"4402100\").on_event(\"change\", num_cluster_changed)\n\n    # UI rules : at startup, the slider is disabled and the checkbox is checked\n    get_widget(self.widget, \"4402100\").disabled = True\n\n    self.update_region_table()\n    # At startup, REGIONSET_TRACE is not visible\n\n    # ============== Tab 3 : substitution ==================\n\n    # We wire the click event on 'Tab 3'\n    get_widget(self.widget, \"42\").on_event(\"click\", self.select_tab_front(3))\n\n    # UI rules :\n    # At startup validate sub-model btn is disabled :\n    get_widget(self.widget, \"4501000\").disabled = True\n\n    # We wire a select event on the 'substitution table' :\n    get_widget(self.widget, \"45001\").set_callback(self.sub_model_selected_callback)\n\n    # We wire a ckick event on the \"validate sub-model\" button :\n    get_widget(self.widget, \"4501000\").on_event(\"click\", self.validate_sub_model)\n    get_widget(self.widget, \"4502\").children = [self.model_explorer.widget]\n\n    # We disable the Substitution table at startup :\n    self.update_substitution_table(None)\n\n    self.refresh_buttons_tab_1()\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.merge_region_clicked","title":"<code>merge_region_clicked(*args)</code>","text":"<p>Called when the user clicks on the 'merge' (regions) button</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def merge_region_clicked(self, *args):\n    \"\"\"\n    Called when the user clicks on the 'merge' (regions) button\n    \"\"\"\n\n    selected_regions = [self.region_set.get(r['Region']) for r in self.selected_regions]\n    mask = None\n    for region in selected_regions:\n        if mask is None:\n            mask = region.mask\n        else:\n            mask |= region.mask\n\n    # compute skope rules\n    skr_rules_list, _ = skope_rules(mask, self.vs_hde.current_X, self.variables)\n\n    # delete regions\n    for region in selected_regions:\n        self.region_set.remove(region.num)\n    # add new region\n    if len(skr_rules_list) &gt; 0:\n        r = self.region_set.add_region(rules=skr_rules_list)\n    else:\n        r = self.region_set.add_region(mask=mask)\n    self.selected_regions = [{'Region': r.num}]\n    self.select_tab(2)\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.new_rules_defined","title":"<code>new_rules_defined(rules_widget, df_mask)</code>","text":"<p>Called by a RulesWidget Skope rule creation or when the user wants new rules to be plotted The function asks the HDEs to display the rules result</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def new_rules_defined(self, rules_widget: RulesWidget, df_mask: pd.Series):\n    \"\"\"\n    Called by a RulesWidget Skope rule creation or when the user wants new rules to be plotted\n    The function asks the HDEs to display the rules result\n    \"\"\"\n    # We sent to the proper HDE the rules_indexes to render :\n    self.vs_hde.figure.display_rules(selection_mask=self.selection_mask, rules_mask=df_mask)\n    self.es_hde.figure.display_rules(selection_mask=self.selection_mask, rules_mask=df_mask)\n\n    # sync selection between rules_widgets\n    if rules_widget == self.vs_rules_wgt:\n        self.es_rules_wgt.update_from_mask(df_mask, RuleSet(), sync=False)\n    else:\n        self.vs_rules_wgt.update_from_mask(df_mask, RuleSet(), sync=False)\n\n    self.refresh_buttons_tab_1()\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.selection_changed","title":"<code>selection_changed(caller, new_selection_mask)</code>","text":"<p>Called when the selection of one HighDimExplorer changes</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def selection_changed(self, caller: HighDimExplorer | None, new_selection_mask: pd.Series):\n    \"\"\"Called when the selection of one HighDimExplorer changes\"\"\"\n\n    # UI rules :\n    # If new selection (empty or not) : if exists, we remove any 'pending rule'\n    self.new_selection = True\n    self.disable_hde()\n    if new_selection_mask.all():\n        # Selection is empty\n        # we display y as color\n        self.select_tab(0)\n        # we reset rules_widgets\n        self.vs_rules_wgt.disable()\n        self.es_rules_wgt.disable()\n        self.es_rules_wgt.reset_widget()\n        self.vs_rules_wgt.reset_widget()\n    else:\n        # Selection is not empty anymore or changes\n        X_rounded = copy.copy((self.X.loc[new_selection_mask])).round(3)\n        change_widget(\n            self.widget,\n            \"432010\",\n            v.DataTable(\n                v_model=[],\n                show_select=False,\n                headers=[{\"text\": column, \"sortable\": True, \"value\": column} for column in self.X.columns],\n                items=X_rounded.to_dict(\"records\"),\n                hide_default_footer=False,\n                disable_sort=False,\n            ),\n        )\n\n    # We store the new selection\n    self.selection_mask = new_selection_mask\n    # We synchronize selection between the two HighDimExplorers\n    if caller is None:\n        self.es_hde.set_selection(self.selection_mask)\n        self.vs_hde.set_selection(self.selection_mask)\n    else:\n        other_hde = self.es_hde if caller == self.vs_hde.figure else self.vs_hde\n        other_hde.set_selection(self.selection_mask)\n\n    # We update the selection status :\n    if not self.selection_mask.all():\n        selection_status_str_1 = f\"{self.selection_mask.sum()} point selected\"\n        selection_status_str_2 = f\"{100 * self.selection_mask.mean():.2f}% of the  dataset\"\n    else:\n        selection_status_str_1 = f\"0 point selected\"\n        selection_status_str_2 = f\"0% of the  dataset\"\n    change_widget(self.widget, \"4300000\", selection_status_str_1)\n    change_widget(self.widget, \"430010\", selection_status_str_2)\n    # we refresh button and enable/disable the datatable\n    self.refresh_buttons_tab_1()\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.show_splash_screen","title":"<code>show_splash_screen()</code>","text":"<p>Displays the splash screen and updates it during the first computations.</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def show_splash_screen(self):\n    \"\"\"Displays the splash screen and updates it during the first computations.\"\"\"\n\n    # We add both widgets to the current notebook cell and hide them\n    IPython.display.display(self.splash_widget, self.widget)\n    self.widget.hide()\n    self.splash_widget.show()\n\n    exp_progress_bar = ProgressBar(\n        get_widget(self.splash_widget, \"110\"),\n        unactive_color=\"light blue\",\n        reset_at_end=False\n    )\n    dimreduc_progress_bar = MultiStepProgressBar(\n        get_widget(self.splash_widget, \"210\"),\n        steps=2,\n        unactive_color=\"light blue\",\n        reset_at_end=False\n    )\n    # We trigger VS proj computation :\n    get_widget(\n        self.splash_widget, \"220\"\n    ).v_model = f\"{config.DEFAULT_PROJECTION} on {self.X.shape} 1/2\"\n\n    self.vs_hde.initialize(progress_callback=dimreduc_progress_bar.get_update(1), X=self.X)\n\n    # We trigger ES explain computation if needed :\n    if not self.exp_values.has_user_exp:  # No imported explanation values\n        exp_method = ExplanationMethod.explain_method_as_str(config.DEFAULT_EXPLANATION_METHOD)\n        msg = f\"Computing {exp_method} on {self.X.shape}\"\n    else:\n        msg = f\"Imported explained values {self.X.shape}\"\n    self.exp_values.initialize(exp_progress_bar.update)\n    get_widget(self.splash_widget, \"120\").v_model = msg\n\n    # THen we trigger ES proj computation :\n    get_widget(\n        self.splash_widget, \"220\"\n    ).v_model = f\"{config.DEFAULT_PROJECTION} on {self.X.shape} 2/2\"\n    self.es_hde.initialize(\n        progress_callback=dimreduc_progress_bar.get_update(2),\n        X=self.exp_values.current_exp_df\n    )\n    self.es_rules_wgt.update_X(self.exp_values.current_exp_df)\n    self.selection_changed(None, boolean_mask(self.X, True))\n\n    self.init_app()\n\n    self.splash_widget.hide()\n    self.widget.show()\n    self.vs_hde.figure.create_figure()\n    self.es_hde.figure.create_figure()\n    self.select_tab(0)\n    self.disable_hde()\n\n    if metadata.counter == 10:\n        self.topbar.open()\n    metadata.save()\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.switch_dimension","title":"<code>switch_dimension(widget, event, data)</code>","text":"<p>Called when the switch changes. We call the HighDimExplorer to update its figure and, enventually, compute its proj</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def switch_dimension(self, widget, event, data):\n    \"\"\"\n    Called when the switch changes.\n    We call the HighDimExplorer to update its figure and, enventually,\n    compute its proj\n    \"\"\"\n    self.set_dimension(3 if data else 2)\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.update_region_table","title":"<code>update_region_table()</code>","text":"<p>Called to empty / fill the RegionDataTable and refresh plots</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def update_region_table(self):\n    \"\"\"\n    Called to empty / fill the RegionDataTable and refresh plots\n    \"\"\"\n    self.region_set.sort(by='size', ascending=False)\n    temp_items = self.region_set.to_dict()\n\n    # We populate the ColorTable :\n    get_widget(self.widget, \"44001\").items = temp_items\n\n    region_stats = self.region_set.stats()\n    str_stats = [\n        f\"{region_stats['regions']} {'regions' if region_stats['regions'] &gt; 1 else 'region'}\",\n        f\"{region_stats['points']} points\",\n        f\"{region_stats['coverage']}% of the dataset\",\n        f\"{region_stats['delta_score']:.2f} subst score\"\n    ]\n    get_widget(self.widget, \"44002\").children = [\n        ', '.join(str_stats)\n    ]\n    get_widget(self.widget, \"4402000\").disabled = False\n</code></pre>"},{"location":"reference/antakia/gui/gui/#antakia.gui.gui.GUI.update_substitution_table","title":"<code>update_substitution_table(region)</code>","text":"<p>Called twice to update table</p> Source code in <code>src/antakia/gui/gui.py</code> <pre><code>def update_substitution_table(self, region: ModelRegion | None):\n    \"\"\"\n    Called twice to update table\n    \"\"\"\n    # set region to called region\n    self.substitute_region = region\n\n    self.update_subtitution_prefix(region)\n    self.update_subtitution_progress_bar()\n    self.update_substitution_title(region)\n</code></pre>"},{"location":"reference/antakia/gui/metadata/","title":"metadata","text":""},{"location":"reference/antakia/gui/progress_bar/","title":"progress_bar","text":""},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar","title":"<code>MultiStepProgressBar</code>","text":"Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>class MultiStepProgressBar:\n    def __init__(self, widget, steps=1, active_color='blue', unactive_color='grey', reset_at_end=True):\n        \"\"\"\n        generic progress bar update\n\n        Parameters\n        ----------\n        widget : widget element\n        steps\n        active_color\n        unactive_color\n        reset_at_end : should we reset widget when 100% is reached\n        \"\"\"\n        self.steps = steps\n        self.widget = widget\n        self.active_color = active_color\n        self.unactive_color = unactive_color\n        self.widget.v_model = 0\n        self.reset_at_end = reset_at_end\n\n    def get_update(self, step):\n        \"\"\"\n        returns the progress updater for the provided step\n        Parameters\n        ----------\n        step\n\n        Returns\n        -------\n\n        \"\"\"\n        if step == 0 or step &gt; self.steps:\n            raise ValueError('step should be between 1 and self.steps')\n\n        def update_ac_progress_bar(progress: float, duration: float):\n            \"\"\"\n            Called by the AutoCluster to update the progress bar\n            \"\"\"\n            self.widget.color = self.active_color\n            progress = round(((step - 1) * 100 + progress) / self.steps)\n            self.set_progress(progress)\n\n        return update_ac_progress_bar\n\n    def set_progress(self, progress):\n        \"\"\"\n        force progress value\n        Parameters\n        ----------\n        progress\n\n        Returns\n        -------\n\n        \"\"\"\n        self.widget.v_model = progress\n        if progress &gt;= 100 and self.reset_at_end:\n            self.reset_progress_bar()\n\n    def reset_progress_bar(self):\n        self.progress = 0\n        self.widget.color = self.unactive_color\n</code></pre>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar.__init__","title":"<code>__init__(widget, steps=1, active_color='blue', unactive_color='grey', reset_at_end=True)</code>","text":"<p>generic progress bar update</p>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar.__init__--parameters","title":"Parameters","text":"<p>widget : widget element steps active_color unactive_color reset_at_end : should we reset widget when 100% is reached</p> Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>def __init__(self, widget, steps=1, active_color='blue', unactive_color='grey', reset_at_end=True):\n    \"\"\"\n    generic progress bar update\n\n    Parameters\n    ----------\n    widget : widget element\n    steps\n    active_color\n    unactive_color\n    reset_at_end : should we reset widget when 100% is reached\n    \"\"\"\n    self.steps = steps\n    self.widget = widget\n    self.active_color = active_color\n    self.unactive_color = unactive_color\n    self.widget.v_model = 0\n    self.reset_at_end = reset_at_end\n</code></pre>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar.get_update","title":"<code>get_update(step)</code>","text":"<p>returns the progress updater for the provided step Parameters</p> <p>step</p>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar.get_update--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>def get_update(self, step):\n    \"\"\"\n    returns the progress updater for the provided step\n    Parameters\n    ----------\n    step\n\n    Returns\n    -------\n\n    \"\"\"\n    if step == 0 or step &gt; self.steps:\n        raise ValueError('step should be between 1 and self.steps')\n\n    def update_ac_progress_bar(progress: float, duration: float):\n        \"\"\"\n        Called by the AutoCluster to update the progress bar\n        \"\"\"\n        self.widget.color = self.active_color\n        progress = round(((step - 1) * 100 + progress) / self.steps)\n        self.set_progress(progress)\n\n    return update_ac_progress_bar\n</code></pre>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar.set_progress","title":"<code>set_progress(progress)</code>","text":"<p>force progress value Parameters</p> <p>progress</p>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.MultiStepProgressBar.set_progress--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>def set_progress(self, progress):\n    \"\"\"\n    force progress value\n    Parameters\n    ----------\n    progress\n\n    Returns\n    -------\n\n    \"\"\"\n    self.widget.v_model = progress\n    if progress &gt;= 100 and self.reset_at_end:\n        self.reset_progress_bar()\n</code></pre>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.ProgressBar","title":"<code>ProgressBar</code>","text":"Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>class ProgressBar:\n    def __init__(self, widget, indeterminate: bool = False, active_color='blue', unactive_color='grey',\n                 reset_at_end=True):\n        \"\"\"\n        generic progress bar update\n        Parameters\n        ----------\n        widget : widget element\n        indeterminate : whether the progress is indeterminate or finegrained\n        active_color\n        unactive_color\n        reset_at_end : should we reset widget when 100% is reached\n        \"\"\"\n        self.active_color = active_color\n        self.unactive_color = unactive_color\n        assert isinstance(widget, (v.ProgressLinear, v.ProgressCircular))\n        self.widget = widget\n        self.indeterminate = indeterminate\n        self.progress = 0\n        self.reset_at_end = reset_at_end\n\n    def update(self, progress: float, time_elapsed):\n        \"\"\"\n\n        Parameters\n        ----------\n        progress: progress value between 0 and 100\n        time_elapsed : duration since start\n\n        Returns\n        -------\n\n        \"\"\"\n        self.progress = progress\n        self.widget.color = self.active_color\n        self.widget.indeterminate = self.indeterminate\n\n\n        if math.ceil(progress) &gt;= 100 and self.reset_at_end:\n            self.reset_progress_bar()\n\n    def reset_progress_bar(self):\n        self.progress = 100\n        self.widget.indeterminate = False\n        self.widget.color = self.unactive_color\n\n    def __call__(self, *args, **kwargs):\n        return self.update(*args, **kwargs)\n\n    @property\n    def progress(self):\n        return self.widget.v_model\n\n    @progress.setter\n    def progress(self, value):\n        if value is None or pd.isna(value):\n            self.widget.indeterminate = True\n        else:\n            if self.indeterminate and value &lt;= 99:\n                self.widget.indeterminate = True\n            else:\n                self.widget.indeterminate = False\n            self.widget.v_model = value\n</code></pre>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.ProgressBar.__init__","title":"<code>__init__(widget, indeterminate=False, active_color='blue', unactive_color='grey', reset_at_end=True)</code>","text":"<p>generic progress bar update Parameters</p> <p>widget : widget element indeterminate : whether the progress is indeterminate or finegrained active_color unactive_color reset_at_end : should we reset widget when 100% is reached</p> Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>def __init__(self, widget, indeterminate: bool = False, active_color='blue', unactive_color='grey',\n             reset_at_end=True):\n    \"\"\"\n    generic progress bar update\n    Parameters\n    ----------\n    widget : widget element\n    indeterminate : whether the progress is indeterminate or finegrained\n    active_color\n    unactive_color\n    reset_at_end : should we reset widget when 100% is reached\n    \"\"\"\n    self.active_color = active_color\n    self.unactive_color = unactive_color\n    assert isinstance(widget, (v.ProgressLinear, v.ProgressCircular))\n    self.widget = widget\n    self.indeterminate = indeterminate\n    self.progress = 0\n    self.reset_at_end = reset_at_end\n</code></pre>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.ProgressBar.update","title":"<code>update(progress, time_elapsed)</code>","text":""},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.ProgressBar.update--parameters","title":"Parameters","text":"<p>progress: progress value between 0 and 100 time_elapsed : duration since start</p>"},{"location":"reference/antakia/gui/progress_bar/#antakia.gui.progress_bar.ProgressBar.update--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/progress_bar.py</code> <pre><code>def update(self, progress: float, time_elapsed):\n    \"\"\"\n\n    Parameters\n    ----------\n    progress: progress value between 0 and 100\n    time_elapsed : duration since start\n\n    Returns\n    -------\n\n    \"\"\"\n    self.progress = progress\n    self.widget.color = self.active_color\n    self.widget.indeterminate = self.indeterminate\n\n\n    if math.ceil(progress) &gt;= 100 and self.reset_at_end:\n        self.reset_progress_bar()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/","title":"ruleswidget","text":""},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RuleWidget","title":"<code>RuleWidget</code>","text":"<p>A piece of UI handled by a RulesExplorer It allows the user to modify one rule</p> <p>Attributes :</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>class RuleWidget:\n    \"\"\"\n    A piece of UI handled by a RulesExplorer\n    It allows the user to modify one rule\n\n    Attributes :\n    \"\"\"\n\n    def __init__(self, rule: Rule, X: pd.DataFrame, y, values_space: bool, init_rules_mask: pd.Series,\n                 rule_updated: callable):\n        '''\n\n        Parameters\n        ----------\n        rule : the rule to be dsplayed\n        X : training dataset\n        y : target variable\n        values_space : bool is value space ?\n        init_rules_mask : reference selection mask\n        rule_updated : callable called on update\n        '''\n        self.rule: Rule = rule\n        self.X: pd.DataFrame = X\n        self.X_col = X.loc[:, rule.variable.column_name]\n        self.values_space: bool = values_space\n        self.rule_updated: callable = rule_updated\n        self.display_sliders: bool = self.values_space # enable rule edit\n        self.root_widget = None\n        self.init_mask = init_rules_mask\n        self.rule_mask = init_rules_mask\n        self.build_widget()\n\n    def build_widget(self):\n        \"\"\"\n        build the widget\n        Returns\n        -------\n\n        \"\"\"\n        # root_widget is an ExpansionPanel\n        self.root_widget: v.ExpansionPanel = v.ExpansionPanel(\n            children=[\n                v.ExpansionPanelHeader(\n                    class_=\"blue lighten-4\",\n                    children=[\n                        \"Placeholder for variable symbol\"  # 1000\n                    ]\n                ),\n                v.ExpansionPanelContent(\n                    children=[\n                        v.Col(\n                            children=[\n                                v.Spacer(),\n                                v.Slider(  # placeholder for select widget\n                                ),\n                            ],\n                        ),\n                        FigureWidget(  # Placeholder for figure\n                        ),\n                    ]\n                ),\n            ]\n        )\n\n        # The variable name bg (ExpansionPanelHeader) is light blue\n        get_widget(self.root_widget, \"0\").class_ = \"blue lighten-4\"\n        self._set_panel_title()\n        # We set the select widget (slider, rangeslider ...)\n        if self.display_sliders:\n            self.select_widget = self._build_select_widget()\n            self._set_select_widget_values()\n            self.select_widget.on_event(\"change\", self._widget_value_changed)\n            change_widget(self.root_widget, \"101\", self.select_widget)\n        else:\n            change_widget(self.root_widget, \"101\", None)\n\n        # Now we build the figure with 3 histograms :\n        self._draw_histograms()\n\n    def _draw_histograms(self):\n        \"\"\"\n        draw the histograms\n        Returns\n        -------\n\n        \"\"\"\n        base_args = {\n            'bingroup': 1,\n            'nbinsx': 50,\n        }\n        mask_color, colors_info = get_mask_comparison_color(self.rule_mask, self.init_mask)\n        h = []\n        for name, color in colors_info.items():\n            h.append(Histogram(\n                name=name,\n                x=self.X_col[mask_color == color],\n                marker_color=color,\n                **base_args\n            ))\n        self.figure = FigureWidget(\n            data=h\n        )\n        self.figure.update_layout(\n            barmode=\"stack\",\n            bargap=0.1,\n            # width=600,\n            showlegend=False,\n            margin={'l': 0, 'r': 0, 't': 0, 'b': 0},\n            height=200,\n        )\n        # display\n        change_widget(self.root_widget, \"11\", self.figure)\n\n    def _set_panel_title(self):\n        \"\"\"\n        compute and display accordion title\n        Returns\n        -------\n\n        \"\"\"\n        if self.rule.is_categorical_rule:\n            title = f\"{self.rule.variable.display_name} possible values :\"\n        elif self.rule.rule_type == 1:  # var &lt; max\n            title = f\"{self.rule.variable.display_name} lesser than {'or equal to ' if self.rule.include_equals else ''}:\"\n        elif self.rule.rule_type == 2:  # var &gt; min\n            title = f\"{self.rule.variable.display_name} greater than {'or equal to ' if self.rule.include_equals else ''}:\"\n        elif self.rule.is_inner_interval_rule:\n            title = f\"{self.rule.variable.display_name} inside the interval:\"\n        else:\n            title = f\"{self.rule.variable.display_name} outside the interval:\"\n        return change_widget(self.root_widget, \"00\", title)\n\n    def _build_select_widget(self):\n        \"\"\"\n        builds the widget to edit the rule\n        Returns\n        -------\n\n        \"\"\"\n        if self.rule.is_categorical_rule:\n            return v.Select(\n                label=self.rule.variable.display_name,\n                items=self.X[self.rule.variable.column_name].unique().tolist(),\n                style_=\"width: 150px\",\n                multiple=True,\n            )\n        min_ = float(self.X[self.rule.variable.column_name].min())\n        max_ = float(self.X[self.rule.variable.column_name].max())\n        min_, max_, step = compute_step(min_, max_)\n        slider_args = {\n            'min': min_,\n            'max': max_,\n            'step': step,\n            'thumb_label': \"always\",\n            'thumb_size': 30,\n            'thumb_color': 'blue'\n        }\n        if self.rule.rule_type == 1:  # var &lt; max\n            slider = v.Slider\n            slider_args['color'] = 'green'\n            slider_args['track_color'] = 'red'\n        elif self.rule.rule_type == 2:  # var &gt; min\n            slider = v.Slider\n            slider_args['color'] = 'red'\n            slider_args['track_color'] = 'green'\n        elif self.rule.is_inner_interval_rule:\n            slider = v.RangeSlider\n            slider_args['color'] = 'green'\n            slider_args['track_color'] = 'red'\n        else:\n            slider = v.RangeSlider\n            slider_args['color'] = 'red'\n            slider_args['track_color'] = 'green'\n        return slider(**slider_args)\n\n    def _set_select_widget_values(self):\n        \"\"\"\n        sets the selection values\n        Returns\n        -------\n\n        \"\"\"\n        if self.rule.is_categorical_rule:\n            self.select_widget.v_model = self.rule.cat_values\n        elif self.rule.rule_type == 1:  # var &lt; max\n            self.select_widget.v_model = [self.rule.max],\n        elif self.rule.rule_type == 2:  # var &gt; min\n            self.select_widget.v_model = [self.rule.min]\n        else:\n            self.select_widget.v_model = [self.rule.min, self.rule.max]\n\n    def _widget_value_changed(self, widget, event, data):\n        \"\"\"\n        callback called when the user edits a value\n\n        should fire rule updated callback\n        Parameters\n        ----------\n        widget\n        event\n        data : new value\n\n        Returns\n        -------\n\n        \"\"\"\n        cat_values = None\n        if self.rule.is_categorical_rule:\n            cat_values = data\n            min_ = max_ = None\n        else:\n            if isinstance(data, list):  # Interval rule\n                min_ = data[0]\n                max_ = data[1]\n            elif self.rule.rule_type == 1:  # var &lt; max\n                min_ = None\n                max_ = data\n            else:\n                min_ = data\n                max_ = None\n        new_rule = Rule(min_, self.rule.operator_min, self.rule.variable, self.rule.operator_max, max_, cat_values)\n        self.rule = new_rule\n        self.rule_updated(new_rule)\n\n    def update(self, new_rules_mask: pd.Series = None, rule: Rule = None):\n        \"\"\" \n            used to update the display (sliders and histogram) to match the new rule\n        \"\"\"\n\n        if rule is not None:\n            self.rule = rule\n        if new_rules_mask is not None:\n            self.rule_mask = new_rules_mask\n        # We update the selects\n        if self.display_sliders:\n            self._set_select_widget_values()\n        mask_color, colors_info = get_mask_comparison_color(self.rule_mask, self.init_mask)\n        with self.figure.batch_update():\n            for i, color in enumerate(colors_info.values()):\n                self.figure.data[i].x = self.X_col[mask_color == color]\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RuleWidget.__init__","title":"<code>__init__(rule, X, y, values_space, init_rules_mask, rule_updated)</code>","text":""},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RuleWidget.__init__--parameters","title":"Parameters","text":"<p>rule : the rule to be dsplayed X : training dataset y : target variable values_space : bool is value space ? init_rules_mask : reference selection mask rule_updated : callable called on update</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def __init__(self, rule: Rule, X: pd.DataFrame, y, values_space: bool, init_rules_mask: pd.Series,\n             rule_updated: callable):\n    '''\n\n    Parameters\n    ----------\n    rule : the rule to be dsplayed\n    X : training dataset\n    y : target variable\n    values_space : bool is value space ?\n    init_rules_mask : reference selection mask\n    rule_updated : callable called on update\n    '''\n    self.rule: Rule = rule\n    self.X: pd.DataFrame = X\n    self.X_col = X.loc[:, rule.variable.column_name]\n    self.values_space: bool = values_space\n    self.rule_updated: callable = rule_updated\n    self.display_sliders: bool = self.values_space # enable rule edit\n    self.root_widget = None\n    self.init_mask = init_rules_mask\n    self.rule_mask = init_rules_mask\n    self.build_widget()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RuleWidget.build_widget","title":"<code>build_widget()</code>","text":"<p>build the widget Returns</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def build_widget(self):\n    \"\"\"\n    build the widget\n    Returns\n    -------\n\n    \"\"\"\n    # root_widget is an ExpansionPanel\n    self.root_widget: v.ExpansionPanel = v.ExpansionPanel(\n        children=[\n            v.ExpansionPanelHeader(\n                class_=\"blue lighten-4\",\n                children=[\n                    \"Placeholder for variable symbol\"  # 1000\n                ]\n            ),\n            v.ExpansionPanelContent(\n                children=[\n                    v.Col(\n                        children=[\n                            v.Spacer(),\n                            v.Slider(  # placeholder for select widget\n                            ),\n                        ],\n                    ),\n                    FigureWidget(  # Placeholder for figure\n                    ),\n                ]\n            ),\n        ]\n    )\n\n    # The variable name bg (ExpansionPanelHeader) is light blue\n    get_widget(self.root_widget, \"0\").class_ = \"blue lighten-4\"\n    self._set_panel_title()\n    # We set the select widget (slider, rangeslider ...)\n    if self.display_sliders:\n        self.select_widget = self._build_select_widget()\n        self._set_select_widget_values()\n        self.select_widget.on_event(\"change\", self._widget_value_changed)\n        change_widget(self.root_widget, \"101\", self.select_widget)\n    else:\n        change_widget(self.root_widget, \"101\", None)\n\n    # Now we build the figure with 3 histograms :\n    self._draw_histograms()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RuleWidget.update","title":"<code>update(new_rules_mask=None, rule=None)</code>","text":"<p>used to update the display (sliders and histogram) to match the new rule</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def update(self, new_rules_mask: pd.Series = None, rule: Rule = None):\n    \"\"\" \n        used to update the display (sliders and histogram) to match the new rule\n    \"\"\"\n\n    if rule is not None:\n        self.rule = rule\n    if new_rules_mask is not None:\n        self.rule_mask = new_rules_mask\n    # We update the selects\n    if self.display_sliders:\n        self._set_select_widget_values()\n    mask_color, colors_info = get_mask_comparison_color(self.rule_mask, self.init_mask)\n    with self.figure.batch_update():\n        for i, color in enumerate(colors_info.values()):\n            self.figure.data[i].x = self.X_col[mask_color == color]\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget","title":"<code>RulesWidget</code>","text":"<p>A RulesWidget is a piece of GUI that allows the user to refine a set of rules. The user can use the slider to change the rules. There are 2 RW : VS and ES slides</p> a dict of list : <p>[[rules_list, scores]]], so that at iteration i we have : i : the list of rules i : the scores as a dict {\"precision\": ?, \"recall\": ?, \"f1\": ?}</p> <p>X : pd.DataFrame, values or explanations Dataframe depending on the context variables : list of Variable rules_mask : list of indexes of the GUI selection (from X.index) is_value_space : bool is_disabled : bool rules_mask : Dataframe mask of the rules rules_updated : callable of the GUI parent root_wiget : its widget representation</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>class RulesWidget:\n    \"\"\"\n    A RulesWidget is a piece of GUI that allows the user to refine a set of rules.\n    The user can use the slider to change the rules.\n    There are 2 RW : VS and ES slides\n\n    rules_db : a dict of list :\n        [[rules_list, scores]]], so that at iteration i we have :\n        [i][0] : the list of rules\n        [i][1] : the scores as a dict {\"precision\": ?, \"recall\": ?, \"f1\": ?}\n    X : pd.DataFrame, values or explanations Dataframe depending on the context\n    variables : list of Variable\n    rules_mask : list of indexes of the GUI selection (from X.index)\n    is_value_space : bool\n    is_disabled : bool\n    rules_mask : Dataframe mask of the rules\n    rules_updated : callable of the GUI parent\n    root_wiget : its widget representation\n    \"\"\"\n\n    def __init__(\n            self,\n            X: pd.DataFrame,\n            y: pd.Series,\n            variables: DataVariables,\n            values_space: bool,\n            new_rules_defined: callable = None,\n    ):\n        \"\"\"\n        widget to manage rule edition and display\n        Parameters\n        ----------\n        X: pd.Dataframe reference dataset\n        y: pd.Series test dataset\n        variables\n        values_space: is the widget on the value space\n        new_rules_defined: callback on rule update\n        \"\"\"\n        self.X = X\n        self.y = y\n        self.variables: DataVariables = variables\n        self.init_rules_mask = None\n        self.is_value_space = values_space\n        self.new_rules_defined = new_rules_defined\n\n        # The root widget is a v.Col - we get it from app_widget\n        self.root_widget = get_widget(app_widget.widget, \"4310\" if values_space else \"4311\")\n\n        self.rules_db = []\n        self.rule_widget_list = []\n\n        # At startup, we are disabled :\n        self.disable()\n\n    def update_X(self, X):\n        \"\"\"\n        change the reference dataset\n        Parameters\n        ----------\n        X: pd.DataFrame\n\n        Returns\n        -------\n\n        \"\"\"\n        if id(X) == id(self.X):\n            return\n        self.X = X\n        self.refresh_widget()\n\n    @property\n    def space(self):\n        return 'values' if self.is_value_space else 'explanations'\n\n    def enable(self):\n        \"\"\"\n        enable widget edition\n        Returns\n        -------\n\n        \"\"\"\n        return self._set_disable(False)\n\n    def disable(self):\n        \"\"\"\n        disable widget edition\n\n        Returns\n        -------\n\n        \"\"\"\n        return self._set_disable(True)\n\n    def _set_disable(self, is_disabled: bool = True):\n        \"\"\"\n        Disabled : card in grey with dummy text + no ExpansionPanels\n        Enabled : card in light blue / ready to display RuleWidgets\n        \"\"\"\n\n        self.is_disabled = is_disabled\n\n        header_html = get_widget(self.root_widget, \"001\")\n        header_html.children = [\n            f\"No rule to display for the {self.space} space\"\n        ]\n        header_html.class_ = \"ml-3 grey--text\" if self.is_disabled else \"ml-3\"\n\n        # We set an empty ExpansionPanels :\n        change_widget(self.root_widget, \"1\", v.ExpansionPanels())\n\n    def init_rules(self, rules_list: RuleSet, score_dict: dict, rules_mask: pd.Series):\n        \"\"\"\n        initialize the widget with the rule list, the score dict (text displayed) and\n        the reference_mask (selection_mask)\n        \"\"\"\n        # we start wih a fresh widget\n        self.reset_widget()\n        self.init_rules_mask = rules_mask\n        if len(rules_list) == 0:\n            self.show_msg(\"No rules found\", \"red--text\")\n            return\n        self.enable()\n        # We populate the db\n        self._put_in_db(rules_list, score_dict)\n\n        # We create the RuleWidgets\n        init_mask = rules_list.get_matching_mask(self.X)\n        self._create_rule_widgets(init_mask)\n        # we display\n        self.refresh_widget()\n\n    def reset_widget(self):\n        \"\"\"\n        a reseted widget is\n        - disabled\n        - history is erased\n        - reference mask is None\n        Returns\n        -------\n\n        \"\"\"\n        self.disable()\n        self.rules_db = []\n        self.rule_widget_list = []\n        self.init_rules_mask = None\n        self.refresh_widget()\n\n    def update_rule(self, new_rule: Rule):\n        \"\"\"\n        callback to synchronize rules in the widget\n        called by the edition of a single rule\n        \"\"\"\n        # We update the rule in the db\n        new_rules_list = self.current_rules_list.copy()\n        new_rules_list.set(new_rule)\n\n        new_rules_mask = new_rules_list.get_matching_mask(self.X)\n        self.update_from_mask(new_rules_mask, new_rules_list)\n\n    def update_from_mask(self, new_rules_mask: pd.Series, new_rules_list: RuleSet, sync=True):\n        \"\"\"\n        updates the widget with the new rule_mask and rule list - the reference_mask is kept for comparison\n        Parameters\n        ----------\n        new_rules_mask : mask to display\n        new_rules_list : rules to base widget on\n        sync : whether or not to call the sync callback (self.new_rules_defined) to update the other rules widget\n\n        Returns\n        -------\n\n        \"\"\"\n        if len(new_rules_list):\n            # update rules\n            try:\n                precision = (new_rules_mask &amp; self.init_rules_mask).sum() / new_rules_mask.sum()\n                recall = (new_rules_mask &amp; self.init_rules_mask).sum() / self.init_rules_mask.sum()\n                f1 = 2 * (precision * recall) / (precision + recall)\n                target_avg = self.y[new_rules_mask].mean()\n            except ZeroDivisionError:\n                precision = recall = f1 = -1\n\n            new_score_dict = {\"precision\": precision, \"recall\": recall, \"f1\": f1, 'target_avg': target_avg}\n\n            self._put_in_db(new_rules_list, new_score_dict)\n\n        # We refresh the widget macro info\n        self.refresh_widget()\n\n        # We update each of our RuleWidgets\n        for rw in self.rule_widget_list:\n            rw.update(new_rules_mask)\n\n        # We notify the GUI and tell there are new rules to draw\n        if self.new_rules_defined is not None and sync:\n            self.new_rules_defined(self, new_rules_mask)\n\n    def undo(self):\n        \"\"\"\n        Restore the previous rules\n        \"\"\"\n        # We remove last rules item from the db:\n        if len(self.rules_db) &gt; 1:\n            self.rules_db.pop(-1)\n\n        # We compute again the rules mask\n        rules_mask = self.current_rules_list.get_matching_mask(self.X)\n\n        def find_rule(rule_widget: RuleWidget) -&gt; Rule:\n            var = rule_widget.rule.variable\n            return self.current_rules_list.find_rule(var)\n\n        # We update each of our RuleWidgets\n        for rw in self.rule_widget_list:\n            rw.update(rules_mask, find_rule(rw))\n\n        # we refresh the widget macro info\n        self.refresh_widget()\n        # We notify the GUI and tell there are new rules to draw if necessary\n        if self.new_rules_defined is not None:\n            self.new_rules_defined(self, rules_mask)\n\n    def _put_in_db(self, rules_list: RuleSet, score_dict: dict):\n        \"\"\"\n        add the rule list to memory\n        Parameters\n        ----------\n        rules_list\n        score_dict\n\n        Returns\n        -------\n\n        \"\"\"\n        self.rules_db.append((rules_list, score_dict))\n\n    def _dump_db(self) -&gt; str:\n        \"\"\"\n        print db\n        Returns\n        -------\n\n        \"\"\"\n        txt = \"\"\n        for i in range(len(self.rules_db)):\n            rules_list = self.rules_db[i][0]\n            scores_dict = self.rules_db[i][1]\n\n            txt += f\"({i}) : {len(rules_list)} rules:\"\n            \"\\n    \".join(rules_list)\n            txt += f\"\\n   scores = {scores_dict}\\n\"\n        return txt\n\n    def _create_rule_widgets(self, init_mask: pd.Series):\n        \"\"\"\n        creates all rule widgets\n                Called by self.init_rules\n                If init_rules_mask is None, we clear all our RuleWidgets\n\n        Parameters\n        ----------\n        init_mask : reference_mask\n\n        Returns\n        -------\n\n        \"\"\"\n        if init_mask is None:\n            return\n\n        # We set new RuleWidget list and put it in our ExpansionPanels children\n        if len(self.current_rules_list) == 0:\n            self.rule_widget_list = []\n        else:\n            self.rule_widget_list = [\n                RuleWidget(rule, self.X, self.y, self.is_value_space, init_mask, self.update_rule)\n                for rule in self.current_rules_list.rules\n            ]\n            get_widget(self.root_widget, \"1\").children = [rule_widget.root_widget for rule_widget in\n                                                          self.rule_widget_list]\n\n    def refresh_widget(self):\n        \"\"\"\n        Sets macro widget info and Datatable: scores and rule details int the DataTable\n        Returns\n        -------\n\n        \"\"\"\n        # We set the title\n        if len(self.current_rules_list) == 0:\n            title = f\"No rule to display for the {'VS' if self.is_value_space else 'ES'} space\"\n        else:\n            title = f\"Rule(s) applied to the {'values' if self.is_value_space else 'explanations'} space\"\n        change_widget(self.root_widget, \"001\", v.Html(class_=\"ml-3\", tag=\"h2\", children=[title]))\n\n        # We set the scores\n        self._show_score()\n\n        # We set the rules\n        self._show_rules()\n\n        # We set the rules in the DataTable\n        change_widget(\n            self.root_widget,\n            \"011\", v.DataTable(\n                v_model=[],\n                show_select=False,\n                headers=[{\"text\": column, \"sortable\": False, \"value\": column} for column in\n                         ['Variable', 'Unit', 'Desc', 'Critical', 'Rule']],\n                items=self.current_rules_list.to_dict(),\n                hide_default_footer=True,\n                disable_sort=True,\n            )\n        )\n\n    def _show_score(self):\n        \"\"\"\n        show rule score\n        Returns\n        -------\n\n        \"\"\"\n        if len(self.current_scores_dict) == 0 or self.is_disabled:\n            scores_txt = \"Precision = n/a, recall = n/a, f1_score = n/a\"\n            css = \"ml-7 grey--text\"\n        elif self.current_scores_dict['precision'] == -1:\n            scores_txt = \"No point of the dataset matches the new rules\"\n            css = \"ml-7 red--text\"\n        else:\n            precision, recall, f1, target_avg = (\n                self.current_scores_dict['precision'], self.current_scores_dict['recall'],\n                self.current_scores_dict['f1'], self.current_scores_dict['target_avg'],\n            )\n            scores_txt = (f\"Precision : {precision:.2f}, recall :{recall:.2f} ,\" +\n                          f\" f1_score : {f1:.2f}, target_avg : {target_avg:.2f}\")\n            css = \"ml-7 black--text\"\n        change_widget(self.root_widget, \"01\", v.Html(class_=css, tag=\"li\", children=[scores_txt]))\n\n    def _show_rules(self):\n        \"\"\"\n        show rules as text\n        Returns\n        -------\n\n        \"\"\"\n        if (\n                len(self.current_rules_list) == 0\n                or self.is_disabled\n        ):\n            rules_txt = \"N/A\"\n            css = \"ml-7 grey--text\"\n        else:\n            rules_txt = repr(self.current_rules_list)\n            css = \"ml-7 blue--text\"\n\n        change_widget(self.root_widget, \"02\", v.Html(class_=css, tag=\"li\", children=[rules_txt]))\n\n    def show_msg(self, msg: str, css: str = \"\"):\n        \"\"\"\n        print a message for the user\n        Parameters\n        ----------\n        msg : message to be printed\n        css : css class to apply\n\n        Returns\n        -------\n\n        \"\"\"\n        css = \"ml-7 \" + css\n        change_widget(self.root_widget, \"02\", v.Html(class_=css, tag=\"li\", children=[msg]))\n\n    @property\n    def current_rules_list(self) -&gt; RuleSet:\n        \"\"\"\n        get the current rule list\n        Returns\n        -------\n\n        \"\"\"\n        if len(self.rules_db) == 0:\n            return RuleSet()\n        else:\n            return self.rules_db[-1][0]\n\n    @property\n    def current_scores_dict(self) -&gt; dict:\n        \"\"\"\n        get the current score dict\n        Returns\n        -------\n\n        \"\"\"\n        if len(self.rules_db) == 0:\n            return {}\n        else:\n            return self.rules_db[-1][1]\n\n    @property\n    def rules_num(self) -&gt; int:\n        \"\"\"\n        get the size of the db\n        Returns\n        -------\n\n        \"\"\"\n        return len(self.rules_db)\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.current_rules_list","title":"<code>current_rules_list: RuleSet</code>  <code>property</code>","text":"<p>get the current rule list Returns</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.current_scores_dict","title":"<code>current_scores_dict: dict</code>  <code>property</code>","text":"<p>get the current score dict Returns</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.rules_num","title":"<code>rules_num: int</code>  <code>property</code>","text":"<p>get the size of the db Returns</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.__init__","title":"<code>__init__(X, y, variables, values_space, new_rules_defined=None)</code>","text":"<p>widget to manage rule edition and display Parameters</p> <p>X: pd.Dataframe reference dataset y: pd.Series test dataset variables values_space: is the widget on the value space new_rules_defined: callback on rule update</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def __init__(\n        self,\n        X: pd.DataFrame,\n        y: pd.Series,\n        variables: DataVariables,\n        values_space: bool,\n        new_rules_defined: callable = None,\n):\n    \"\"\"\n    widget to manage rule edition and display\n    Parameters\n    ----------\n    X: pd.Dataframe reference dataset\n    y: pd.Series test dataset\n    variables\n    values_space: is the widget on the value space\n    new_rules_defined: callback on rule update\n    \"\"\"\n    self.X = X\n    self.y = y\n    self.variables: DataVariables = variables\n    self.init_rules_mask = None\n    self.is_value_space = values_space\n    self.new_rules_defined = new_rules_defined\n\n    # The root widget is a v.Col - we get it from app_widget\n    self.root_widget = get_widget(app_widget.widget, \"4310\" if values_space else \"4311\")\n\n    self.rules_db = []\n    self.rule_widget_list = []\n\n    # At startup, we are disabled :\n    self.disable()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.disable","title":"<code>disable()</code>","text":"<p>disable widget edition</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.disable--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def disable(self):\n    \"\"\"\n    disable widget edition\n\n    Returns\n    -------\n\n    \"\"\"\n    return self._set_disable(True)\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.enable","title":"<code>enable()</code>","text":"<p>enable widget edition Returns</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def enable(self):\n    \"\"\"\n    enable widget edition\n    Returns\n    -------\n\n    \"\"\"\n    return self._set_disable(False)\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.init_rules","title":"<code>init_rules(rules_list, score_dict, rules_mask)</code>","text":"<p>initialize the widget with the rule list, the score dict (text displayed) and the reference_mask (selection_mask)</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def init_rules(self, rules_list: RuleSet, score_dict: dict, rules_mask: pd.Series):\n    \"\"\"\n    initialize the widget with the rule list, the score dict (text displayed) and\n    the reference_mask (selection_mask)\n    \"\"\"\n    # we start wih a fresh widget\n    self.reset_widget()\n    self.init_rules_mask = rules_mask\n    if len(rules_list) == 0:\n        self.show_msg(\"No rules found\", \"red--text\")\n        return\n    self.enable()\n    # We populate the db\n    self._put_in_db(rules_list, score_dict)\n\n    # We create the RuleWidgets\n    init_mask = rules_list.get_matching_mask(self.X)\n    self._create_rule_widgets(init_mask)\n    # we display\n    self.refresh_widget()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.refresh_widget","title":"<code>refresh_widget()</code>","text":"<p>Sets macro widget info and Datatable: scores and rule details int the DataTable Returns</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def refresh_widget(self):\n    \"\"\"\n    Sets macro widget info and Datatable: scores and rule details int the DataTable\n    Returns\n    -------\n\n    \"\"\"\n    # We set the title\n    if len(self.current_rules_list) == 0:\n        title = f\"No rule to display for the {'VS' if self.is_value_space else 'ES'} space\"\n    else:\n        title = f\"Rule(s) applied to the {'values' if self.is_value_space else 'explanations'} space\"\n    change_widget(self.root_widget, \"001\", v.Html(class_=\"ml-3\", tag=\"h2\", children=[title]))\n\n    # We set the scores\n    self._show_score()\n\n    # We set the rules\n    self._show_rules()\n\n    # We set the rules in the DataTable\n    change_widget(\n        self.root_widget,\n        \"011\", v.DataTable(\n            v_model=[],\n            show_select=False,\n            headers=[{\"text\": column, \"sortable\": False, \"value\": column} for column in\n                     ['Variable', 'Unit', 'Desc', 'Critical', 'Rule']],\n            items=self.current_rules_list.to_dict(),\n            hide_default_footer=True,\n            disable_sort=True,\n        )\n    )\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.reset_widget","title":"<code>reset_widget()</code>","text":"<p>a reseted widget is - disabled - history is erased - reference mask is None Returns</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def reset_widget(self):\n    \"\"\"\n    a reseted widget is\n    - disabled\n    - history is erased\n    - reference mask is None\n    Returns\n    -------\n\n    \"\"\"\n    self.disable()\n    self.rules_db = []\n    self.rule_widget_list = []\n    self.init_rules_mask = None\n    self.refresh_widget()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.show_msg","title":"<code>show_msg(msg, css='')</code>","text":"<p>print a message for the user Parameters</p> <p>msg : message to be printed css : css class to apply</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.show_msg--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def show_msg(self, msg: str, css: str = \"\"):\n    \"\"\"\n    print a message for the user\n    Parameters\n    ----------\n    msg : message to be printed\n    css : css class to apply\n\n    Returns\n    -------\n\n    \"\"\"\n    css = \"ml-7 \" + css\n    change_widget(self.root_widget, \"02\", v.Html(class_=css, tag=\"li\", children=[msg]))\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.undo","title":"<code>undo()</code>","text":"<p>Restore the previous rules</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def undo(self):\n    \"\"\"\n    Restore the previous rules\n    \"\"\"\n    # We remove last rules item from the db:\n    if len(self.rules_db) &gt; 1:\n        self.rules_db.pop(-1)\n\n    # We compute again the rules mask\n    rules_mask = self.current_rules_list.get_matching_mask(self.X)\n\n    def find_rule(rule_widget: RuleWidget) -&gt; Rule:\n        var = rule_widget.rule.variable\n        return self.current_rules_list.find_rule(var)\n\n    # We update each of our RuleWidgets\n    for rw in self.rule_widget_list:\n        rw.update(rules_mask, find_rule(rw))\n\n    # we refresh the widget macro info\n    self.refresh_widget()\n    # We notify the GUI and tell there are new rules to draw if necessary\n    if self.new_rules_defined is not None:\n        self.new_rules_defined(self, rules_mask)\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.update_X","title":"<code>update_X(X)</code>","text":"<p>change the reference dataset Parameters</p> <p>X: pd.DataFrame</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.update_X--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def update_X(self, X):\n    \"\"\"\n    change the reference dataset\n    Parameters\n    ----------\n    X: pd.DataFrame\n\n    Returns\n    -------\n\n    \"\"\"\n    if id(X) == id(self.X):\n        return\n    self.X = X\n    self.refresh_widget()\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.update_from_mask","title":"<code>update_from_mask(new_rules_mask, new_rules_list, sync=True)</code>","text":"<p>updates the widget with the new rule_mask and rule list - the reference_mask is kept for comparison Parameters</p> <p>new_rules_mask : mask to display new_rules_list : rules to base widget on sync : whether or not to call the sync callback (self.new_rules_defined) to update the other rules widget</p>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.update_from_mask--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def update_from_mask(self, new_rules_mask: pd.Series, new_rules_list: RuleSet, sync=True):\n    \"\"\"\n    updates the widget with the new rule_mask and rule list - the reference_mask is kept for comparison\n    Parameters\n    ----------\n    new_rules_mask : mask to display\n    new_rules_list : rules to base widget on\n    sync : whether or not to call the sync callback (self.new_rules_defined) to update the other rules widget\n\n    Returns\n    -------\n\n    \"\"\"\n    if len(new_rules_list):\n        # update rules\n        try:\n            precision = (new_rules_mask &amp; self.init_rules_mask).sum() / new_rules_mask.sum()\n            recall = (new_rules_mask &amp; self.init_rules_mask).sum() / self.init_rules_mask.sum()\n            f1 = 2 * (precision * recall) / (precision + recall)\n            target_avg = self.y[new_rules_mask].mean()\n        except ZeroDivisionError:\n            precision = recall = f1 = -1\n\n        new_score_dict = {\"precision\": precision, \"recall\": recall, \"f1\": f1, 'target_avg': target_avg}\n\n        self._put_in_db(new_rules_list, new_score_dict)\n\n    # We refresh the widget macro info\n    self.refresh_widget()\n\n    # We update each of our RuleWidgets\n    for rw in self.rule_widget_list:\n        rw.update(new_rules_mask)\n\n    # We notify the GUI and tell there are new rules to draw\n    if self.new_rules_defined is not None and sync:\n        self.new_rules_defined(self, new_rules_mask)\n</code></pre>"},{"location":"reference/antakia/gui/ruleswidget/#antakia.gui.ruleswidget.RulesWidget.update_rule","title":"<code>update_rule(new_rule)</code>","text":"<p>callback to synchronize rules in the widget called by the edition of a single rule</p> Source code in <code>src/antakia/gui/ruleswidget.py</code> <pre><code>def update_rule(self, new_rule: Rule):\n    \"\"\"\n    callback to synchronize rules in the widget\n    called by the edition of a single rule\n    \"\"\"\n    # We update the rule in the db\n    new_rules_list = self.current_rules_list.copy()\n    new_rules_list.set(new_rule)\n\n    new_rules_mask = new_rules_list.get_matching_mask(self.X)\n    self.update_from_mask(new_rules_mask, new_rules_list)\n</code></pre>"},{"location":"reference/antakia/gui/widget_utils/","title":"widget_utils","text":""},{"location":"reference/antakia/gui/widget_utils/#antakia.gui.widget_utils.get_widget","title":"<code>get_widget(root_widget, address)</code>","text":"<p>Returns a sub widget of root_widget. Address is a sequence of childhood ranks as a string Return sub_widget may be modified, it's still the same sub_widget of the root_widget get_widget(root_widget, '0') returns root_widgetn first child TODO : allow childhood rank &gt; 9</p> Source code in <code>src/antakia/gui/widget_utils.py</code> <pre><code>def get_widget(root_widget: Widget, address: str) -&gt; Widget:\n    \"\"\"\n    Returns a sub widget of root_widget. Address is a sequence of childhood ranks as a string\n    Return sub_widget may be modified, it's still the same sub_widget of the root_widget\n    get_widget(root_widget, '0') returns root_widgetn first child\n    TODO : allow childhood rank &gt; 9\n    \"\"\"\n    if not address:\n        return root_widget\n\n    try:\n        address = [int(i) for i in address]\n    except ValueError:\n        raise ValueError(address, \"must be a string composed of digits\")\n    try:\n        return recursive_get_widget(root_widget, address)\n    except:\n        raise IndexError(f\"Nothing found @{address} in this {root_widget.__class__.__name__}\")\n</code></pre>"},{"location":"reference/antakia/gui/widgets/","title":"widgets","text":""},{"location":"reference/antakia/gui/widgets/#antakia.gui.widgets.change_widget","title":"<code>change_widget(root_widget, address, sub_widget)</code>","text":"<p>Substitutes a sub_widget in a root_widget. Address is a sequence of childhood ranks as a string, root_widget first child address is  '0' The root_widget is altered but the object remains the same</p> Source code in <code>src/antakia/gui/widgets.py</code> <pre><code>def change_widget(root_widget: Widget, address: str, sub_widget: Widget | str):\n    \"\"\"\n    Substitutes a sub_widget in a root_widget.\n    Address is a sequence of childhood ranks as a string, root_widget first child address is  '0'\n    The root_widget is altered but the object remains the same\n    \"\"\"\n    try:\n        int(address)\n    except ValueError:\n        raise ValueError(address, \"must be a string composed of digits\")\n\n    parent_widget = _get_parent(root_widget, address)\n    new_children = []\n    for i in range(len(parent_widget.children)):\n        if i == int(address[-1]):\n            if sub_widget is not None:\n                new_children.append(sub_widget)\n        else:\n            new_children.append(parent_widget.children[i])\n    parent_widget.children = new_children\n</code></pre>"},{"location":"reference/antakia/gui/widgets/#antakia.gui.widgets.check_address","title":"<code>check_address(root_widget, address)</code>","text":"<p>For debug purposes : check if the address is reachable and returns the widget class</p> Source code in <code>src/antakia/gui/widgets.py</code> <pre><code>def check_address(root_widget: Widget, address: str) -&gt; str:\n    \"\"\"\n    For debug purposes : check if the address is reachable and returns the widget class\n    \"\"\"\n\n    widget = root_widget.children[int(address[0])]\n    txt = f\"[{address[0]}] : {widget.__class__.__name__}\"\n    if len(address) == 1:\n        return txt\n    elif widget is not None and len(widget.children) &gt; 0:\n        # let's continue further :\n        return txt + \", \" + check_address(widget, address[1:])\n    else:\n        # address targets a non existent widget :\n        return txt + f\", nothing @[{address[0]}]\"\n</code></pre>"},{"location":"reference/antakia/gui/widgets/#antakia.gui.widgets.get_widget","title":"<code>get_widget(root_widget, address)</code>","text":"<p>Returns a sub widget of root_widget. Address is a sequence of childhood ranks as a string Return sub_widget may be modified, it's still the same sub_widget of the root_widget get_widget(root_widget, '0') returns root_widgetn first child TODO : allow childhood rank &gt; 9</p> Source code in <code>src/antakia/gui/widgets.py</code> <pre><code>def get_widget(root_widget: Widget, address: str) -&gt; Widget:\n    \"\"\"\n    Returns a sub widget of root_widget. Address is a sequence of childhood ranks as a string\n    Return sub_widget may be modified, it's still the same sub_widget of the root_widget\n    get_widget(root_widget, '0') returns root_widgetn first child\n    TODO : allow childhood rank &gt; 9\n    \"\"\"\n    try:\n        int(address)\n    except ValueError:\n        raise ValueError(address, \"must be a string composed of digits\")\n\n    if len(address) &gt; 1:\n        try:\n            return get_widget(root_widget.children[int(address[0])], address[1:])\n        except IndexError:\n            raise IndexError(f\"Nothing found @{address} in this {root_widget.__class__.__name__}\")\n    else:\n        if isinstance(root_widget, v.Tooltip):\n            return root_widget.v_slots[0][\"children\"]\n        else:\n            return root_widget.children[int(address[0])]\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/__init__/","title":"init","text":""},{"location":"reference/antakia/gui/high_dim_exp/figure_display/","title":"figure_display","text":""},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay","title":"<code>FigureDisplay</code>","text":"<p>A FigureDisplay objet manages all operation on a scatter plot  This class is only responsible for displaying the provided data</p> <p>It can display in 3 or 2 dimensions.</p> <p>Attributes :</p> Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>class FigureDisplay:\n    \"\"\"\n    A FigureDisplay objet manages all operation on a scatter plot \n    This class is only responsible for displaying the provided data\n\n    It can display in 3 or 2 dimensions.\n\n    Attributes :\n\n    \"\"\"\n\n    # Trace indexes : 0 for values, 1 for rules, 2 for regions\n    NUM_TRACES = 4\n    VALUES_TRACE = 0\n    RULES_TRACE = 1\n    REGIONSET_TRACE = 2\n    REGION_TRACE = 3\n\n    @staticmethod\n    def trace_name(trace_id: int) -&gt; str:\n        \"\"\"\n        get trace name from id\n        Parameters\n        ----------\n        trace_id : int\n\n        Returns\n        -------\n\n        \"\"\"\n        if trace_id == FigureDisplay.VALUES_TRACE:\n            return 'values trace'\n        elif trace_id == FigureDisplay.RULES_TRACE:\n            return 'rules trace'\n        elif trace_id == FigureDisplay.REGIONSET_TRACE:\n            return 'regionset trace'\n        elif trace_id == FigureDisplay.REGION_TRACE:\n            return 'region trace'\n        else:\n            return \"unknown trace\"\n\n    def __init__(\n            self,\n            X: pd.DataFrame | None,\n            y: pd.Series,\n            selection_changed: callable,\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        X: data to display, should be 2 or 3D \n        y: target value (default color)\n        selection_changed : callable called when a selection changed\n        \"\"\"\n        # current active tab\n        self.active_tab = 0\n        # mask of value to display to limit points on graph\n        self._mask = None\n        # callback to notify gui that the selection has changed\n        self.selection_changed = selection_changed\n        # projected values handler &amp; widget\n        self.X = X\n        self.y = y\n\n        # Now we can init figure\n        self.widget = v.Container()\n        self.widget.class_ = \"flex-fill\"\n\n        # display parameters\n        self.fig_width = config.INIT_FIG_WIDTH / 2\n        self.fig_height = config.INIT_FIG_WIDTH / 4\n\n        # is graph selectable\n        self._selection_mode = 'lasso'\n        # current selection\n        if X is not None:\n            self._current_selection = utils.boolean_mask(self.X, True)\n        else:\n            self._current_selection = None\n        # is this selection first since last deselection ?\n        self.first_selection = True\n\n        # traces to show\n        self._visible = [True, False, False, False]\n        # trace_colors\n        self._colors: list[pd.Series | None] = [None, None, None, None]\n\n        # figures\n        self.figure_2D = self.figure_3D = None\n        # is the class fully initialized\n        self.initialized = False\n\n    @property\n    def figure(self):\n        if self.dim == 2:\n            return self.figure_2D\n        else:\n            return self.figure_3D\n\n    @figure.setter\n    def figure(self, value):\n        if self.dim == 2:\n            self.figure_2D = value\n        else:\n            self.figure_3D = value\n\n    @property\n    def dim(self):\n        if self.X is None:\n            return config.DEFAULT_DIMENSION\n        return self.X.shape[1]\n\n    @property\n    def current_selection(self):\n        if self._current_selection is None:\n            self._current_selection = utils.boolean_mask(self.X, True)\n        return self._current_selection\n\n    @current_selection.setter\n    def current_selection(self, value):\n        self._current_selection = value\n\n    def initialize(self, X: pd.DataFrame = None):\n        \"\"\"\n        inital computation called at startup, after init to compute required values\n        Parameters\n        ----------\n        X : data to display, if NOne use the one provided during init\n\n        Returns\n        -------\n\n        \"\"\"\n        if X is not None:\n            self.X = X\n        self.create_figure()\n        self.initialized = True\n\n    # ---- display Methods ------\n\n    def disable_selection(self, is_disabled: bool):\n        \"\"\"\n        enable/disable selection on graph\n        Parameters\n        ----------\n        is_disabled\n\n        Returns\n        -------\n\n        \"\"\"\n\n        self._selection_mode = False if is_disabled else \"lasso\"\n        if self.dim == 2 and self.figure is not None:\n            self.figure.update_layout(\n                dragmode=self._selection_mode\n            )\n\n    def _show_trace(self, trace_id: int, show: bool):\n        \"\"\"\n        show/hide trace\n        Parameters\n        ----------\n        trace_id : trace to change\n        show : show/hide\n\n        Returns\n        -------\n\n        \"\"\"\n        self._visible[trace_id] = show\n        self.figure.data[trace_id].visible = show\n\n    def display_rules(self, selection_mask: pd.Series, rules_mask: pd.Series = None):\n        \"\"\"\n        display a rule vs a selection\n        Parameters\n        ----------\n        selection_mask: boolean series of selected points\n        rules_mask: boolean series of rule validating points\n\n        Returns\n        -------\n\n        \"\"\"\n        if selection_mask.all():\n            selection_mask = ~selection_mask\n        if rules_mask is None:\n            rules_mask = selection_mask\n        color, _ = utils.get_mask_comparison_color(rules_mask, selection_mask)\n\n        self._colors[self.RULES_TRACE] = color\n        self._display_zones(self.RULES_TRACE)\n\n    def display_regionset(self, region_set: RegionSet):\n        \"\"\"\n        display a region set, each region in its color\n        Parameters\n        ----------\n        region_set\n\n        Returns\n        -------\n\n        \"\"\"\n        self._colors[self.REGIONSET_TRACE] = region_set.get_color_serie()\n        self._display_zones(self.REGIONSET_TRACE)\n\n    def display_region(self, region: Region):\n        \"\"\"\n        display a single region\n        Parameters\n        ----------\n        region\n\n        Returns\n        -------\n\n        \"\"\"\n        rs = RegionSet(self.X)\n        rs.add(region)\n        self._colors[self.REGION_TRACE] = rs.get_color_serie()\n        self._display_zones(self.REGION_TRACE)\n\n    def _display_zones(self, trace=None):\n        \"\"\"\n        refresh provided trace or all trace if None\n        do not alter visibility\n        Parameters\n        ----------\n        trace\n\n        Returns\n        -------\n\n        \"\"\"\n\n        if trace is None:\n            for trace_id in range(self.NUM_TRACES):\n                self.refresh_trace(trace_id=trace_id)\n        else:\n            self.refresh_trace(trace_id=trace)\n\n    def set_color(self, color: pd.Series, trace_id: int):\n        \"\"\"\n        set the provided color as the scatter point color on the provided trace id\n        do not alter show/hide trace\n        Parameters\n        ----------\n        color\n        trace_id\n\n        Returns\n        -------\n\n        \"\"\"\n        self._colors[trace_id] = color\n        self.refresh_trace(trace_id)\n\n    def refresh_trace(self, trace_id: int):\n        \"\"\"\n        refresh the provided trace id\n        do not alter show/hide trace\n\n        Parameters\n        ----------\n        trace_id\n\n        Returns\n        -------\n\n        \"\"\"\n        if self.figure is None:\n            self.create_figure()\n        else:\n            colors = self._colors[trace_id]\n            if colors is None:\n                colors = self.y\n            colors = colors[self.mask]\n            with self.figure.batch_update():\n                self.figure.data[trace_id].marker.color = colors\n\n\n    def update_X(self, X: pd.DataFrame):\n        \"\"\"\n        changes the underlying data - update the data used in display and dimension is necessary\n        Parameters\n        ----------\n        X : data to display\n\n        Returns\n        -------\n\n        \"\"\"\n        self.X = X\n        self.redraw()\n\n    def selection_to_mask(self, row_numbers):\n        \"\"\"\n\n        extrapolate selected row_numbers to full dataframe and return the selection mask on all the dataframe\n\n        Parameters\n        ----------\n        row_numbers\n\n        Returns\n        -------\n\n        \"\"\"\n        selection = utils.rows_to_mask(self.X[self.mask], row_numbers)\n        if not selection.any() or selection.all():\n            return utils.boolean_mask(self.get_X(masked=False), selection.mean())\n        if self.mask.all():\n            return selection\n        X_train = self.get_X(masked=True)\n        knn = KNeighborsClassifier().fit(X_train, selection)\n        X_predict = self.get_X(masked=False)\n        guessed_selection = pd.Series(knn.predict(X_predict), index=X_predict.index)\n        # KNN extrapolation\n        return guessed_selection.astype(bool)\n\n    def _selection_event(self, trace, points, *args):\n        \"\"\"\n        callback triggered by selection on graph\n        selects points and update display on both hde (calls selection changed)\n        deselects if no points selected\n\n        update selection taking intersection\n        Parameters\n        ----------\n        trace\n        points\n        args\n\n        Returns\n        -------\n\n        \"\"\"\n        self.first_selection |= self.current_selection.all()\n        self.current_selection &amp;= self.selection_to_mask(points.point_inds)\n        self.display_rules(self.current_selection)\n        if self.current_selection.any():\n            self.create_figure()\n            self.selection_changed(self, self.current_selection)\n        else:\n            self._deselection_event(rebuild=True)\n\n    def _deselection_event(self, *args, rebuild=False):\n        \"\"\"\n        clear selection -- called by deselection on graph\n        synchronize hdes\n\n        Parameters\n        ----------\n        args\n        rebuild\n\n        Returns\n        -------\n\n        \"\"\"\n        # We tell the GUI\n        self.first_selection = False\n        self.current_selection = utils.boolean_mask(self.X, True)\n        self.selection_changed(self, self.current_selection)\n        self.display_rules(~self.current_selection, ~self.current_selection)\n        if rebuild:\n            self.create_figure()\n        else:\n            self.display_selection()\n\n    def set_selection(self, new_selection_mask: pd.Series):\n        \"\"\"\n        update selection from mask\n        no update_callback\n        Called by tne UI when a new selection occurred on the other HDE\n        Parameters\n        ----------\n        new_selection_mask\n\n        Returns\n        -------\n\n        \"\"\"\n\n        if self.current_selection.all() and new_selection_mask.all():\n            # New selection is empty. We already have an empty selection : nothing to do\n            return\n\n        # selection event\n        self.current_selection = new_selection_mask\n        self.display_rules(self.current_selection, self.current_selection)\n        self.display_selection()\n        return\n\n    def display_selection(self):\n        \"\"\"\n        display selection on figure\n        Returns\n        -------\n\n        \"\"\"\n        if self.dim == 2:\n            fig = self.figure.data[0]\n            fig.update(selectedpoints=utils.mask_to_rows(self.current_selection[self.mask]))\n            fig.selectedpoints = utils.mask_to_rows(self.current_selection[self.mask])\n\n    @property\n    def mask(self):\n        \"\"\"\n        mask should be applied on each display (x,y,z,color, selection)\n        \"\"\"\n        if self._mask is None:\n            self._mask = pd.Series([False] * len(self.X), index=self.X.index)\n            limit = config.MAX_DOTS\n            if len(self.X) &gt; limit:\n                indices = np.random.choice(self.X.index, size=limit, replace=False)\n                self._mask.loc[indices] = True\n            else:\n                self._mask.loc[:] = True\n        return self._mask\n\n    def create_figure(self):\n        \"\"\"\n        Builds the FigureWidget for the given dimension\n        \"\"\"\n        x = y = z = None\n\n        if self.X is not None:\n            proj_values = self.get_X(masked=True)\n\n        hde_marker = {'color': self.y, 'colorscale': \"Viridis\"}\n        if self.dim == 3:\n            hde_marker['size'] = 2\n\n        fig_args = {\n            'x': proj_values[0],\n            'y': proj_values[1],\n            'mode': \"markers\",\n            'marker': hde_marker,\n            'customdata': self.y[self.mask],\n            'hovertemplate': \"%{customdata:.3f}\",\n        }\n        if self.dim == 3:\n            fig_args['z'] = proj_values[2]\n            fig_builder = Scatter3d\n        else:\n            fig_builder = Scattergl\n\n        self.figure = FigureWidget(data=[fig_builder(**fig_args)])  # Trace 0 for dots\n        self.figure.add_trace(fig_builder(**fig_args))  # Trace 1 for rules\n        self.figure.add_trace(fig_builder(**fig_args))  # Trace 2 for region set\n        self.figure.add_trace(fig_builder(**fig_args))  # Trace 3 for region\n\n        self.figure.update_layout(dragmode=self._selection_mode)\n        self.figure.update_traces(\n            selected={\"marker\": {\"opacity\": 1.0}},\n            unselected={\"marker\": {\"opacity\": 0.1}},\n            selector={'type': \"scatter\"}\n        )\n        self.figure.update_layout(\n            autosize=True,\n            margin={\n                't': 0,\n                'b': 0,\n                'l': 0,\n                'r': 0\n            },\n        )\n        self.figure._config = self.figure._config | {\"displaylogo\": False}\n        self.figure._config = self.figure._config | {'displayModeBar': True}\n        # We don't want the name of the trace to appear :\n        for trace_id in range(len(self.figure.data)):\n            self.figure.data[trace_id].showlegend = False\n            self._show_trace(trace_id, self._visible[trace_id])\n            self.refresh_trace(trace_id)\n        self.display_selection()\n\n        if self.dim == 2:\n            # selection only on trace 0\n            self.figure.data[0].on_selection(self._selection_event)\n            self.figure.data[0].on_deselect(self._deselection_event)\n\n        self.widget.children = [self.figure]\n\n    def redraw(self):\n        \"\"\"\n        redraw all traces, without recreating figure\n        Returns\n        -------\n\n        \"\"\"\n        if self.figure is None:\n            self.create_figure()\n        projection = self.get_X(masked=True)\n\n        with self.figure.batch_update():\n            for trace_id in range(len(self.figure.data)):\n                self.figure.data[trace_id].x = projection[0]\n                self.figure.data[trace_id].y = projection[1]\n                if self.dim == 3:\n                    self.figure.data[trace_id].z = projection[2]\n                self.figure.data[trace_id].showlegend = False\n                self._show_trace(trace_id, self._visible[trace_id])\n                self.refresh_trace(trace_id)\n        self.widget.children = [self.figure]\n\n    def get_X(self, masked: bool) -&gt; pd.DataFrame | None:\n        \"\"\"\n\n        return current projection value\n        its computes it if necessary - progress is published in the callback\n\n        Parameters\n        ----------\n        masked\n\n        Returns\n        -------\n\n        \"\"\"\n        if masked and self.X is not None:\n            return self.X.loc[self.mask]\n        return self.X\n\n    def set_tab(self, tab):\n        \"\"\"\n        show/hide trace depending on tab\n        Parameters\n        ----------\n        tab\n\n        Returns\n        -------\n\n        \"\"\"\n        self.disable_selection(tab &gt; 1)\n        self._show_trace(self.VALUES_TRACE, tab == 0)\n        self._show_trace(self.RULES_TRACE, tab == 1)\n        self._show_trace(self.REGIONSET_TRACE, tab == 2)\n        self._show_trace(self.REGION_TRACE, tab == 3)\n        # and it's the only place where selection is allowed\n        self.active_tab = tab\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.mask","title":"<code>mask</code>  <code>property</code>","text":"<p>mask should be applied on each display (x,y,z,color, selection)</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.__init__","title":"<code>__init__(X, y, selection_changed)</code>","text":""},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.__init__--parameters","title":"Parameters","text":"<p>X: data to display, should be 2 or 3D  y: target value (default color) selection_changed : callable called when a selection changed</p> Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def __init__(\n        self,\n        X: pd.DataFrame | None,\n        y: pd.Series,\n        selection_changed: callable,\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    X: data to display, should be 2 or 3D \n    y: target value (default color)\n    selection_changed : callable called when a selection changed\n    \"\"\"\n    # current active tab\n    self.active_tab = 0\n    # mask of value to display to limit points on graph\n    self._mask = None\n    # callback to notify gui that the selection has changed\n    self.selection_changed = selection_changed\n    # projected values handler &amp; widget\n    self.X = X\n    self.y = y\n\n    # Now we can init figure\n    self.widget = v.Container()\n    self.widget.class_ = \"flex-fill\"\n\n    # display parameters\n    self.fig_width = config.INIT_FIG_WIDTH / 2\n    self.fig_height = config.INIT_FIG_WIDTH / 4\n\n    # is graph selectable\n    self._selection_mode = 'lasso'\n    # current selection\n    if X is not None:\n        self._current_selection = utils.boolean_mask(self.X, True)\n    else:\n        self._current_selection = None\n    # is this selection first since last deselection ?\n    self.first_selection = True\n\n    # traces to show\n    self._visible = [True, False, False, False]\n    # trace_colors\n    self._colors: list[pd.Series | None] = [None, None, None, None]\n\n    # figures\n    self.figure_2D = self.figure_3D = None\n    # is the class fully initialized\n    self.initialized = False\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.create_figure","title":"<code>create_figure()</code>","text":"<p>Builds the FigureWidget for the given dimension</p> Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def create_figure(self):\n    \"\"\"\n    Builds the FigureWidget for the given dimension\n    \"\"\"\n    x = y = z = None\n\n    if self.X is not None:\n        proj_values = self.get_X(masked=True)\n\n    hde_marker = {'color': self.y, 'colorscale': \"Viridis\"}\n    if self.dim == 3:\n        hde_marker['size'] = 2\n\n    fig_args = {\n        'x': proj_values[0],\n        'y': proj_values[1],\n        'mode': \"markers\",\n        'marker': hde_marker,\n        'customdata': self.y[self.mask],\n        'hovertemplate': \"%{customdata:.3f}\",\n    }\n    if self.dim == 3:\n        fig_args['z'] = proj_values[2]\n        fig_builder = Scatter3d\n    else:\n        fig_builder = Scattergl\n\n    self.figure = FigureWidget(data=[fig_builder(**fig_args)])  # Trace 0 for dots\n    self.figure.add_trace(fig_builder(**fig_args))  # Trace 1 for rules\n    self.figure.add_trace(fig_builder(**fig_args))  # Trace 2 for region set\n    self.figure.add_trace(fig_builder(**fig_args))  # Trace 3 for region\n\n    self.figure.update_layout(dragmode=self._selection_mode)\n    self.figure.update_traces(\n        selected={\"marker\": {\"opacity\": 1.0}},\n        unselected={\"marker\": {\"opacity\": 0.1}},\n        selector={'type': \"scatter\"}\n    )\n    self.figure.update_layout(\n        autosize=True,\n        margin={\n            't': 0,\n            'b': 0,\n            'l': 0,\n            'r': 0\n        },\n    )\n    self.figure._config = self.figure._config | {\"displaylogo\": False}\n    self.figure._config = self.figure._config | {'displayModeBar': True}\n    # We don't want the name of the trace to appear :\n    for trace_id in range(len(self.figure.data)):\n        self.figure.data[trace_id].showlegend = False\n        self._show_trace(trace_id, self._visible[trace_id])\n        self.refresh_trace(trace_id)\n    self.display_selection()\n\n    if self.dim == 2:\n        # selection only on trace 0\n        self.figure.data[0].on_selection(self._selection_event)\n        self.figure.data[0].on_deselect(self._deselection_event)\n\n    self.widget.children = [self.figure]\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.disable_selection","title":"<code>disable_selection(is_disabled)</code>","text":"<p>enable/disable selection on graph Parameters</p> <p>is_disabled</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.disable_selection--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def disable_selection(self, is_disabled: bool):\n    \"\"\"\n    enable/disable selection on graph\n    Parameters\n    ----------\n    is_disabled\n\n    Returns\n    -------\n\n    \"\"\"\n\n    self._selection_mode = False if is_disabled else \"lasso\"\n    if self.dim == 2 and self.figure is not None:\n        self.figure.update_layout(\n            dragmode=self._selection_mode\n        )\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_region","title":"<code>display_region(region)</code>","text":"<p>display a single region Parameters</p> <p>region</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_region--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def display_region(self, region: Region):\n    \"\"\"\n    display a single region\n    Parameters\n    ----------\n    region\n\n    Returns\n    -------\n\n    \"\"\"\n    rs = RegionSet(self.X)\n    rs.add(region)\n    self._colors[self.REGION_TRACE] = rs.get_color_serie()\n    self._display_zones(self.REGION_TRACE)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_regionset","title":"<code>display_regionset(region_set)</code>","text":"<p>display a region set, each region in its color Parameters</p> <p>region_set</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_regionset--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def display_regionset(self, region_set: RegionSet):\n    \"\"\"\n    display a region set, each region in its color\n    Parameters\n    ----------\n    region_set\n\n    Returns\n    -------\n\n    \"\"\"\n    self._colors[self.REGIONSET_TRACE] = region_set.get_color_serie()\n    self._display_zones(self.REGIONSET_TRACE)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_rules","title":"<code>display_rules(selection_mask, rules_mask=None)</code>","text":"<p>display a rule vs a selection Parameters</p> <p>selection_mask: boolean series of selected points rules_mask: boolean series of rule validating points</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_rules--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def display_rules(self, selection_mask: pd.Series, rules_mask: pd.Series = None):\n    \"\"\"\n    display a rule vs a selection\n    Parameters\n    ----------\n    selection_mask: boolean series of selected points\n    rules_mask: boolean series of rule validating points\n\n    Returns\n    -------\n\n    \"\"\"\n    if selection_mask.all():\n        selection_mask = ~selection_mask\n    if rules_mask is None:\n        rules_mask = selection_mask\n    color, _ = utils.get_mask_comparison_color(rules_mask, selection_mask)\n\n    self._colors[self.RULES_TRACE] = color\n    self._display_zones(self.RULES_TRACE)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.display_selection","title":"<code>display_selection()</code>","text":"<p>display selection on figure Returns</p> Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def display_selection(self):\n    \"\"\"\n    display selection on figure\n    Returns\n    -------\n\n    \"\"\"\n    if self.dim == 2:\n        fig = self.figure.data[0]\n        fig.update(selectedpoints=utils.mask_to_rows(self.current_selection[self.mask]))\n        fig.selectedpoints = utils.mask_to_rows(self.current_selection[self.mask])\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.get_X","title":"<code>get_X(masked)</code>","text":"<p>return current projection value its computes it if necessary - progress is published in the callback</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.get_X--parameters","title":"Parameters","text":"<p>masked</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.get_X--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def get_X(self, masked: bool) -&gt; pd.DataFrame | None:\n    \"\"\"\n\n    return current projection value\n    its computes it if necessary - progress is published in the callback\n\n    Parameters\n    ----------\n    masked\n\n    Returns\n    -------\n\n    \"\"\"\n    if masked and self.X is not None:\n        return self.X.loc[self.mask]\n    return self.X\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.initialize","title":"<code>initialize(X=None)</code>","text":"<p>inital computation called at startup, after init to compute required values Parameters</p> <p>X : data to display, if NOne use the one provided during init</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.initialize--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def initialize(self, X: pd.DataFrame = None):\n    \"\"\"\n    inital computation called at startup, after init to compute required values\n    Parameters\n    ----------\n    X : data to display, if NOne use the one provided during init\n\n    Returns\n    -------\n\n    \"\"\"\n    if X is not None:\n        self.X = X\n    self.create_figure()\n    self.initialized = True\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.redraw","title":"<code>redraw()</code>","text":"<p>redraw all traces, without recreating figure Returns</p> Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def redraw(self):\n    \"\"\"\n    redraw all traces, without recreating figure\n    Returns\n    -------\n\n    \"\"\"\n    if self.figure is None:\n        self.create_figure()\n    projection = self.get_X(masked=True)\n\n    with self.figure.batch_update():\n        for trace_id in range(len(self.figure.data)):\n            self.figure.data[trace_id].x = projection[0]\n            self.figure.data[trace_id].y = projection[1]\n            if self.dim == 3:\n                self.figure.data[trace_id].z = projection[2]\n            self.figure.data[trace_id].showlegend = False\n            self._show_trace(trace_id, self._visible[trace_id])\n            self.refresh_trace(trace_id)\n    self.widget.children = [self.figure]\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.refresh_trace","title":"<code>refresh_trace(trace_id)</code>","text":"<p>refresh the provided trace id do not alter show/hide trace</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.refresh_trace--parameters","title":"Parameters","text":"<p>trace_id</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.refresh_trace--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def refresh_trace(self, trace_id: int):\n    \"\"\"\n    refresh the provided trace id\n    do not alter show/hide trace\n\n    Parameters\n    ----------\n    trace_id\n\n    Returns\n    -------\n\n    \"\"\"\n    if self.figure is None:\n        self.create_figure()\n    else:\n        colors = self._colors[trace_id]\n        if colors is None:\n            colors = self.y\n        colors = colors[self.mask]\n        with self.figure.batch_update():\n            self.figure.data[trace_id].marker.color = colors\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.selection_to_mask","title":"<code>selection_to_mask(row_numbers)</code>","text":"<p>extrapolate selected row_numbers to full dataframe and return the selection mask on all the dataframe</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.selection_to_mask--parameters","title":"Parameters","text":"<p>row_numbers</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.selection_to_mask--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def selection_to_mask(self, row_numbers):\n    \"\"\"\n\n    extrapolate selected row_numbers to full dataframe and return the selection mask on all the dataframe\n\n    Parameters\n    ----------\n    row_numbers\n\n    Returns\n    -------\n\n    \"\"\"\n    selection = utils.rows_to_mask(self.X[self.mask], row_numbers)\n    if not selection.any() or selection.all():\n        return utils.boolean_mask(self.get_X(masked=False), selection.mean())\n    if self.mask.all():\n        return selection\n    X_train = self.get_X(masked=True)\n    knn = KNeighborsClassifier().fit(X_train, selection)\n    X_predict = self.get_X(masked=False)\n    guessed_selection = pd.Series(knn.predict(X_predict), index=X_predict.index)\n    # KNN extrapolation\n    return guessed_selection.astype(bool)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.set_color","title":"<code>set_color(color, trace_id)</code>","text":"<p>set the provided color as the scatter point color on the provided trace id do not alter show/hide trace Parameters</p> <p>color trace_id</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.set_color--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def set_color(self, color: pd.Series, trace_id: int):\n    \"\"\"\n    set the provided color as the scatter point color on the provided trace id\n    do not alter show/hide trace\n    Parameters\n    ----------\n    color\n    trace_id\n\n    Returns\n    -------\n\n    \"\"\"\n    self._colors[trace_id] = color\n    self.refresh_trace(trace_id)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.set_selection","title":"<code>set_selection(new_selection_mask)</code>","text":"<p>update selection from mask no update_callback Called by tne UI when a new selection occurred on the other HDE Parameters</p> <p>new_selection_mask</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.set_selection--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def set_selection(self, new_selection_mask: pd.Series):\n    \"\"\"\n    update selection from mask\n    no update_callback\n    Called by tne UI when a new selection occurred on the other HDE\n    Parameters\n    ----------\n    new_selection_mask\n\n    Returns\n    -------\n\n    \"\"\"\n\n    if self.current_selection.all() and new_selection_mask.all():\n        # New selection is empty. We already have an empty selection : nothing to do\n        return\n\n    # selection event\n    self.current_selection = new_selection_mask\n    self.display_rules(self.current_selection, self.current_selection)\n    self.display_selection()\n    return\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.set_tab","title":"<code>set_tab(tab)</code>","text":"<p>show/hide trace depending on tab Parameters</p> <p>tab</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.set_tab--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def set_tab(self, tab):\n    \"\"\"\n    show/hide trace depending on tab\n    Parameters\n    ----------\n    tab\n\n    Returns\n    -------\n\n    \"\"\"\n    self.disable_selection(tab &gt; 1)\n    self._show_trace(self.VALUES_TRACE, tab == 0)\n    self._show_trace(self.RULES_TRACE, tab == 1)\n    self._show_trace(self.REGIONSET_TRACE, tab == 2)\n    self._show_trace(self.REGION_TRACE, tab == 3)\n    # and it's the only place where selection is allowed\n    self.active_tab = tab\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.trace_name","title":"<code>trace_name(trace_id)</code>  <code>staticmethod</code>","text":"<p>get trace name from id Parameters</p> <p>trace_id : int</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.trace_name--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>@staticmethod\ndef trace_name(trace_id: int) -&gt; str:\n    \"\"\"\n    get trace name from id\n    Parameters\n    ----------\n    trace_id : int\n\n    Returns\n    -------\n\n    \"\"\"\n    if trace_id == FigureDisplay.VALUES_TRACE:\n        return 'values trace'\n    elif trace_id == FigureDisplay.RULES_TRACE:\n        return 'rules trace'\n    elif trace_id == FigureDisplay.REGIONSET_TRACE:\n        return 'regionset trace'\n    elif trace_id == FigureDisplay.REGION_TRACE:\n        return 'region trace'\n    else:\n        return \"unknown trace\"\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.update_X","title":"<code>update_X(X)</code>","text":"<p>changes the underlying data - update the data used in display and dimension is necessary Parameters</p> <p>X : data to display</p>"},{"location":"reference/antakia/gui/high_dim_exp/figure_display/#antakia.gui.high_dim_exp.figure_display.FigureDisplay.update_X--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/figure_display.py</code> <pre><code>def update_X(self, X: pd.DataFrame):\n    \"\"\"\n    changes the underlying data - update the data used in display and dimension is necessary\n    Parameters\n    ----------\n    X : data to display\n\n    Returns\n    -------\n\n    \"\"\"\n    self.X = X\n    self.redraw()\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/","title":"highdimexplorer","text":""},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer","title":"<code>HighDimExplorer</code>","text":"<p>An HighDimExplorer displays one high dim Dataframes on a scatter plot. This class is only responsible for displaying the provided projection dimensionality reduction is handled by ProjectedValueSelector</p> <p>It can display in 3 or 2 dimensions.</p> <p>Implementation details : It handles projections computation and switch through ProjectedValueSelector it can update its high dim dataframe through the update_pv method</p> <p>Attributes are mostly privates (underscorred) since they are not meant to be used outside of the class.</p> <p>Attributes :</p> Source code in <code>src/antakia/gui/high_dim_exp/highdimexplorer.py</code> <pre><code>class HighDimExplorer:\n    \"\"\"\n    An HighDimExplorer displays one high dim Dataframes on a scatter plot.\n    This class is only responsible for displaying the provided projection\n    dimensionality reduction is handled by ProjectedValueSelector\n\n    It can display in 3 or 2 dimensions.\n\n    Implementation details :\n    It handles projections computation and switch through ProjectedValueSelector\n    it can update its high dim dataframe through the update_pv method\n\n    Attributes are mostly privates (underscorred) since they are not meant to be used outside of the class.\n\n    Attributes :\n\n    \"\"\"\n\n    def __init__(\n            self,\n            pv_bank: ProjectedValueBank,\n            selection_changed: callable,\n            space\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        pv_bank: projected values storage\n        selection_changed : callable called when a selection changed\n        \"\"\"\n        self.pv_bank = pv_bank\n\n        # projected values handler &amp; widget\n        self.projected_value_selector = ProjectedValuesSelector(\n            pv_bank,\n            self.refresh,\n            space\n        )\n\n        self.figure = FigureDisplay(\n            None,\n            pv_bank.y,\n            selection_changed\n        )\n\n        self.initialized = False\n\n    def get_current_X_proj(self, dim=None, progress_callback=None) -&gt; pd.DataFrame | None:\n        return self.projected_value_selector.get_current_X_proj(dim, progress_callback)\n\n    def initialize(self, progress_callback, X: pd.DataFrame):\n        \"\"\"\n        inital computation (called at startup, after init to compute required values\n        Parameters\n        ----------\n        progress_callback : callable to notify progress\n\n        Returns\n        -------\n\n        \"\"\"\n        self.projected_value_selector.initialize(progress_callback, X)\n        self.figure.initialize(self.get_current_X_proj())\n        self.initialized = True\n\n    def disable(self, disable_figure: bool, disable_projection: bool):\n        \"\"\"\n        disable dropdown select\n        Parameters\n        ----------\n        is_disabled: disable value\n\n        Returns\n        -------\n\n        \"\"\"\n        self.figure.disable_selection(disable_figure)\n        self.projected_value_selector.disable(disable_projection)\n\n    def refresh(self, progress_callback=None):\n        self.disable(True, True)\n        self.figure.update_X(self.get_current_X_proj(progress_callback=progress_callback))\n        self.disable(False, False)\n\n    def update_X(self, X: pd.DataFrame, progress_callback=None):\n        \"\"\"\n        changes the undelying projected value instance - update the data used in display\n        Parameters\n        ----------\n        pv\n        progress_callback\n\n        Returns\n        -------\n\n        \"\"\"\n        self.projected_value_selector.update_X(X)\n        self.refresh(progress_callback)\n\n    @property\n    def current_pv(self):\n        return self.projected_value_selector.projected_value\n\n    @property\n    def current_X(self) -&gt; pd.DataFrame | None:\n        \"\"\"\n        return hde current X value (not projected)\n\n        Returns\n        -------\n\n        \"\"\"\n        if self.projected_value_selector is None:\n            return None  # When we're an ES HDE and no explanation have been imported nor computed yet\n        return self.projected_value_selector.projected_value.X\n\n    def set_tab(self, *args, **kwargs):\n        return self.figure.set_tab(*args, **kwargs)\n\n    def set_selection(self, *args, **kwargs):\n        return self.figure.set_selection(*args, **kwargs)\n\n    def set_dim(self, dim: int):\n        self.projected_value_selector.update_dim(dim)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.current_X","title":"<code>current_X: pd.DataFrame | None</code>  <code>property</code>","text":"<p>return hde current X value (not projected)</p>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.current_X--returns","title":"Returns","text":""},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.__init__","title":"<code>__init__(pv_bank, selection_changed, space)</code>","text":""},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.__init__--parameters","title":"Parameters","text":"<p>pv_bank: projected values storage selection_changed : callable called when a selection changed</p> Source code in <code>src/antakia/gui/high_dim_exp/highdimexplorer.py</code> <pre><code>def __init__(\n        self,\n        pv_bank: ProjectedValueBank,\n        selection_changed: callable,\n        space\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    pv_bank: projected values storage\n    selection_changed : callable called when a selection changed\n    \"\"\"\n    self.pv_bank = pv_bank\n\n    # projected values handler &amp; widget\n    self.projected_value_selector = ProjectedValuesSelector(\n        pv_bank,\n        self.refresh,\n        space\n    )\n\n    self.figure = FigureDisplay(\n        None,\n        pv_bank.y,\n        selection_changed\n    )\n\n    self.initialized = False\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.disable","title":"<code>disable(disable_figure, disable_projection)</code>","text":"<p>disable dropdown select Parameters</p> <p>is_disabled: disable value</p>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.disable--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/highdimexplorer.py</code> <pre><code>def disable(self, disable_figure: bool, disable_projection: bool):\n    \"\"\"\n    disable dropdown select\n    Parameters\n    ----------\n    is_disabled: disable value\n\n    Returns\n    -------\n\n    \"\"\"\n    self.figure.disable_selection(disable_figure)\n    self.projected_value_selector.disable(disable_projection)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.initialize","title":"<code>initialize(progress_callback, X)</code>","text":"<p>inital computation (called at startup, after init to compute required values Parameters</p> <p>progress_callback : callable to notify progress</p>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.initialize--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/highdimexplorer.py</code> <pre><code>def initialize(self, progress_callback, X: pd.DataFrame):\n    \"\"\"\n    inital computation (called at startup, after init to compute required values\n    Parameters\n    ----------\n    progress_callback : callable to notify progress\n\n    Returns\n    -------\n\n    \"\"\"\n    self.projected_value_selector.initialize(progress_callback, X)\n    self.figure.initialize(self.get_current_X_proj())\n    self.initialized = True\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.update_X","title":"<code>update_X(X, progress_callback=None)</code>","text":"<p>changes the undelying projected value instance - update the data used in display Parameters</p> <p>pv progress_callback</p>"},{"location":"reference/antakia/gui/high_dim_exp/highdimexplorer/#antakia.gui.high_dim_exp.highdimexplorer.HighDimExplorer.update_X--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/highdimexplorer.py</code> <pre><code>def update_X(self, X: pd.DataFrame, progress_callback=None):\n    \"\"\"\n    changes the undelying projected value instance - update the data used in display\n    Parameters\n    ----------\n    pv\n    progress_callback\n\n    Returns\n    -------\n\n    \"\"\"\n    self.projected_value_selector.update_X(X)\n    self.refresh(progress_callback)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/projected_value_bank/","title":"projected_value_bank","text":""},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/","title":"projected_values_selector","text":""},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector","title":"<code>ProjectedValuesSelector</code>","text":"Source code in <code>src/antakia/gui/high_dim_exp/projected_values_selector.py</code> <pre><code>class ProjectedValuesSelector:\n    def __init__(self, pv_bank: ProjectedValueBank, update_callback: callable, space):\n        self.widget = None\n        self.progress_bar = None\n        self.projected_value = None\n        self._proj_params_cards = {}\n        self.update_callback = update_callback\n        self.pv_bank = pv_bank\n        self.space = space\n\n        self.X = None\n        self.current_proj = Proj(\n            DimReducMethod.dimreduc_method_as_int(config.DEFAULT_PROJECTION),\n            config.DEFAULT_DIMENSION\n        )\n\n        self.build_widget()\n\n    @property\n    def current_dim(self):\n        return self.current_proj.dimension\n\n    def build_widget(self):\n        self.widget = v.Row(children=[\n            v.Select(  # Selection of proj method\n                label=f\"Projection in the {self.space} :\",\n                items=DimReducMethod.dimreduc_methods_as_str_list(),\n                style_=\"width: 15%\",\n                class_=\"ml-2 mr-2\",\n            ),\n            v.Menu(  # proj settings\n                class_=\"ml-2 mr-2\",\n                v_slots=[\n                    {\n                        \"name\": \"activator\",\n                        \"variable\": \"props\",\n                        \"children\": v.Btn(\n                            v_on=\"props.on\",\n                            icon=True,\n                            size=\"x-large\",\n                            children=[\n                                v.Icon(\n                                    children=[\"mdi-cogs\"],\n                                    size=\"large\",\n                                )\n                            ],\n                            class_=\"ma-2 pa-3\",\n                            elevation=\"3\",\n                        ),\n                    }\n                ],\n                children=[\n                    v.Card(  # 1410\n                        class_=\"pa-4\",\n                        rounded=True,\n                        children=[\n                            widgets.VBox(  # 14100\n                                [\n                                    v.Slider(  # 141000\n                                        class_=\"ma-8 pa-2\",\n                                        v_model=10,\n                                        min=5,\n                                        max=30,\n                                        step=1,\n                                        label=\"Number of neighbours\",\n                                        thumb_label=\"always\",\n                                        thumb_size=25,\n                                    ),\n                                    v.Slider(  # 141001\n                                        class_=\"ma-8 pa-2\",\n                                        v_model=0.5,\n                                        min=0.1,\n                                        max=0.9,\n                                        step=0.1,\n                                        label=\"MN ratio\",\n                                        thumb_label=\"always\",\n                                        thumb_size=25,\n                                    ),\n                                    v.Slider(  # 141002\n                                        class_=\"ma-8 pa-2\",\n                                        v_model=2,\n                                        min=0.1,\n                                        max=5,\n                                        step=0.1,\n                                        label=\"FP ratio\",\n                                        thumb_label=\"always\",\n                                        thumb_size=25,\n                                    )\n                                ],\n                            )\n                        ],\n                        min_width=\"500\",\n                    )\n                ],\n                v_model=False,\n                close_on_content_click=False,\n                offset_y=True,\n            ),\n            v.ProgressCircular(  # progress bar\n                indeterminate=True,\n                color=\"blue\",\n                width=\"6\",\n                size=\"35\",\n                class_=\"ml-2 mr-2 mt-2\",\n            )\n        ])\n        self.progress_bar = ProgressBar(self.widget.children[2], indeterminate=True)\n        self.progress_bar.update(100, 0)\n        self.projection_select.on_event(\"change\", self.projection_select_changed)\n        self.build_all_proj_param_w()\n        self.projection_select.on_event(\"change\", self.projection_select_changed)\n\n    def initialize(self, progress_callback, X: pd.DataFrame):\n        self.projected_value = self.pv_bank.get_projected_values(X)\n        self.get_current_X_proj(progress_callback=progress_callback)\n        self.refresh()\n\n    def refresh(self):\n        self.disable(True)\n        self.projection_select.v_model = DimReducMethod.dimreduc_method_as_str(\n            self.current_proj.reduction_method\n        )\n        self.update_proj_params_menu()\n        self.update_callback()\n        self.disable(False)\n\n    def update_X(self, X: pd.DataFrame):\n        self.projected_value = self.pv_bank.get_projected_values(X)\n        self.refresh()\n\n    def update_dim(self, dim):\n        self.current_proj = Proj(self.current_proj.reduction_method, dim)\n        self.refresh()\n\n    @property\n    def projection_select(self):\n        \"\"\"\n        get dim reduc selector\n        Returns\n        -------\n\n        \"\"\"\n        return self.widget.children[0]\n\n    @property\n    def projection_method(self) -&gt; int:\n        \"\"\"\n        returns the current projection method\n        Returns\n        -------\n\n        \"\"\"\n        if self.projection_select.v_model == '!!disabled!!':\n            self.projection_select.v_model = config.DEFAULT_PROJECTION\n        return DimReducMethod.dimreduc_method_as_int(\n            self.projection_select.v_model\n        )\n\n    def projection_select_changed(self, *args):\n        \"\"\"\n        callback called on projection select change\n        projection is computed if needed\n        Parameters\n        ----------\n        widget\n        event\n        data\n\n        Returns\n        -------\n\n        \"\"\"\n        self.current_proj = Proj(self.projection_method, self.current_dim)\n        self.update_proj_params_menu()\n        self.refresh()\n\n    @property\n    def proj_param_widget(self):\n        \"\"\"\n        get the projection parameter widget\n        Returns\n        -------\n\n        \"\"\"\n        return self.widget.children[1]\n\n    def build_proj_param_widget(self, dim_reduc) -&gt; list[v.Slider]:\n        \"\"\"\n        build widget\n        Parameters\n        ----------\n        dim_reduc\n\n        Returns\n        -------\n\n        \"\"\"\n        parameters = dim_reduc_factory[dim_reduc].parameters()\n        sliders = []\n        for param, info in parameters.items():\n            min_, max_, step = utils.compute_step(info['min'], info['max'])\n            default_value = info['default']\n            if info['type'] == int:\n                step = max(round(step), 1)\n\n            slider = v.Slider(  # 15000\n                class_=\"ma-8 pa-2\",\n                v_model=default_value,\n                min=float(min_),\n                max=float(max_),\n                step=step,\n                label=param,\n                thumb_label=\"always\",\n                thumb_size=25,\n            )\n            slider.on_event(\"change\", self.params_changed)\n            sliders.append(slider)\n        return sliders\n\n    def update_proj_param_value(self):\n        parameters = self.projected_value.get_parameters(self.current_proj)['current']\n        param_widget = self._proj_params_cards[self.projection_method]\n        for slider in param_widget:\n            slider.v_model = parameters[slider.label]\n\n    def build_all_proj_param_w(self):\n        for dim_reduc in DimReducMethod.dimreduc_methods_as_list():\n            self._proj_params_cards[dim_reduc] = self.build_proj_param_widget(dim_reduc)\n\n    def params_changed(self, widget, event, data):\n        \"\"\"\n        called when user changes a parameter value\n        Parameters\n        ----------\n        widget: caller widget\n        event -\n        data : new value\n\n        Returns\n        -------\n\n        \"\"\"\n        self.update_params(widget.label, data)\n\n    def update_params(self, parameter, new_value):\n        self.projected_value.set_parameters(self.current_proj,\n                                            {parameter: new_value})\n        self.refresh()\n\n    def update_proj_params_menu(self):\n        \"\"\"\n        Called at startup by the GUI\n        \"\"\"\n        # We return\n        params = self._proj_params_cards[self.projection_method]\n        # We neet to set a Card, depending on the projection method\n        self.proj_param_widget.children[0].children = [widgets.VBox(params)]\n        self.update_proj_param_value()\n\n    def disable_select(self, is_disabled: bool):\n        self.projection_select.disabled = is_disabled\n\n    def disable_params(self, is_disabled: bool):\n        self.proj_param_widget.disabled = is_disabled\n\n    def disable(self, is_disabled):\n        params = self._proj_params_cards[self.projection_method]\n        self.disable_select(is_disabled)\n        # do not enable proj parama menu if there are no parameters\n        is_disabled |= len(params) == 0\n        self.disable_params(is_disabled)\n\n    def get_current_X_proj(self, dim=None, progress_callback=None) -&gt; pd.DataFrame | None:\n        \"\"\"\n        get current project X\n        Parameters\n        ----------\n        dim: dimension to get, if None use current\n        progress_callback: callback to publish progress to, if None use default\n\n        Returns\n        -------\n\n        \"\"\"\n        if dim is None:\n            dim = self.current_dim\n        if progress_callback is None:\n            progress_callback = self.progress_bar.update\n        X = self.projected_value.get_projection(\n            Proj(self.current_proj.reduction_method, dim), progress_callback\n        )\n        return X\n\n    def is_computed(self, projection_method=None, dim=None) -&gt; bool:\n        if projection_method is None:\n            projection_method = self.projection_method\n        if dim is None:\n            dim = self.current_dim\n        return self.projected_value.is_present(Proj(projection_method, dim))\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.proj_param_widget","title":"<code>proj_param_widget</code>  <code>property</code>","text":"<p>get the projection parameter widget Returns</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.projection_method","title":"<code>projection_method: int</code>  <code>property</code>","text":"<p>returns the current projection method Returns</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.projection_select","title":"<code>projection_select</code>  <code>property</code>","text":"<p>get dim reduc selector Returns</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.build_proj_param_widget","title":"<code>build_proj_param_widget(dim_reduc)</code>","text":"<p>build widget Parameters</p> <p>dim_reduc</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.build_proj_param_widget--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/projected_values_selector.py</code> <pre><code>def build_proj_param_widget(self, dim_reduc) -&gt; list[v.Slider]:\n    \"\"\"\n    build widget\n    Parameters\n    ----------\n    dim_reduc\n\n    Returns\n    -------\n\n    \"\"\"\n    parameters = dim_reduc_factory[dim_reduc].parameters()\n    sliders = []\n    for param, info in parameters.items():\n        min_, max_, step = utils.compute_step(info['min'], info['max'])\n        default_value = info['default']\n        if info['type'] == int:\n            step = max(round(step), 1)\n\n        slider = v.Slider(  # 15000\n            class_=\"ma-8 pa-2\",\n            v_model=default_value,\n            min=float(min_),\n            max=float(max_),\n            step=step,\n            label=param,\n            thumb_label=\"always\",\n            thumb_size=25,\n        )\n        slider.on_event(\"change\", self.params_changed)\n        sliders.append(slider)\n    return sliders\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.get_current_X_proj","title":"<code>get_current_X_proj(dim=None, progress_callback=None)</code>","text":"<p>get current project X Parameters</p> <p>dim: dimension to get, if None use current progress_callback: callback to publish progress to, if None use default</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.get_current_X_proj--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/projected_values_selector.py</code> <pre><code>def get_current_X_proj(self, dim=None, progress_callback=None) -&gt; pd.DataFrame | None:\n    \"\"\"\n    get current project X\n    Parameters\n    ----------\n    dim: dimension to get, if None use current\n    progress_callback: callback to publish progress to, if None use default\n\n    Returns\n    -------\n\n    \"\"\"\n    if dim is None:\n        dim = self.current_dim\n    if progress_callback is None:\n        progress_callback = self.progress_bar.update\n    X = self.projected_value.get_projection(\n        Proj(self.current_proj.reduction_method, dim), progress_callback\n    )\n    return X\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.params_changed","title":"<code>params_changed(widget, event, data)</code>","text":"<p>called when user changes a parameter value Parameters</p> <p>widget: caller widget event - data : new value</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.params_changed--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/projected_values_selector.py</code> <pre><code>def params_changed(self, widget, event, data):\n    \"\"\"\n    called when user changes a parameter value\n    Parameters\n    ----------\n    widget: caller widget\n    event -\n    data : new value\n\n    Returns\n    -------\n\n    \"\"\"\n    self.update_params(widget.label, data)\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.projection_select_changed","title":"<code>projection_select_changed(*args)</code>","text":"<p>callback called on projection select change projection is computed if needed Parameters</p> <p>widget event data</p>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.projection_select_changed--returns","title":"Returns","text":"Source code in <code>src/antakia/gui/high_dim_exp/projected_values_selector.py</code> <pre><code>def projection_select_changed(self, *args):\n    \"\"\"\n    callback called on projection select change\n    projection is computed if needed\n    Parameters\n    ----------\n    widget\n    event\n    data\n\n    Returns\n    -------\n\n    \"\"\"\n    self.current_proj = Proj(self.projection_method, self.current_dim)\n    self.update_proj_params_menu()\n    self.refresh()\n</code></pre>"},{"location":"reference/antakia/gui/high_dim_exp/projected_values_selector/#antakia.gui.high_dim_exp.projected_values_selector.ProjectedValuesSelector.update_proj_params_menu","title":"<code>update_proj_params_menu()</code>","text":"<p>Called at startup by the GUI</p> Source code in <code>src/antakia/gui/high_dim_exp/projected_values_selector.py</code> <pre><code>def update_proj_params_menu(self):\n    \"\"\"\n    Called at startup by the GUI\n    \"\"\"\n    # We return\n    params = self._proj_params_cards[self.projection_method]\n    # We neet to set a Card, depending on the projection method\n    self.proj_param_widget.children[0].children = [widgets.VBox(params)]\n    self.update_proj_param_value()\n</code></pre>"},{"location":"reference/antakia/gui/tabs/__init__/","title":"init","text":""},{"location":"reference/antakia/gui/tabs/model_explorer/","title":"model_explorer","text":""},{"location":"reference/antakia/gui/tabs/model_explorer/#antakia.gui.tabs.model_explorer.ModelExplorer","title":"<code>ModelExplorer</code>","text":"<p>This is ModelExplorer docstring.</p> Source code in <code>src/antakia/gui/tabs/model_explorer.py</code> <pre><code>class ModelExplorer:\n    \"\"\"\n    This is ModelExplorer docstring.\n    \"\"\"\n\n    def __init__(self, X: pd.DataFrame):\n        self.build_widget()\n        self.model: MLModel | None = None\n        self.region: ModelRegion | None = None\n        self.X = X\n        pass\n\n    def build_widget(self):\n        self.feature_importance_tab = v.TabItem(  # Tab 1) feature importances # 43\n            class_=\"mt-2\",\n            children=[]\n        )\n        self.pdp_feature_select = v.Select()\n        self.pdp_figure = v.Container()\n        self.widget = v.Tabs(\n            v_model=0,  # default active tab\n            children=[\n                         v.Tab(children=[\"Feature Importance\"]),\n                         v.Tab(children=[\"Partial Dependency\"]),\n                     ]\n                     +\n                     [\n                         self.feature_importance_tab,\n                         v.TabItem(  # Tab 2) Partial dependence\n                             children=[\n                                 v.Col(\n                                     children=[\n                                         self.pdp_feature_select,\n                                         self.pdp_figure\n                                     ]\n                                 )\n                             ]\n                         ),  # End of v.TabItem #2\n                     ]\n        )\n        self.pdp_feature_select.on_event('change', self.display_pdp)\n\n    def update_selected_model(self, model: MLModel, region: ModelRegion):\n        self.model = model\n        self.region = region\n        self.update_feature_importances()\n        self.update_pdp_tab()\n\n    def update_feature_importances(self):\n        if self.model is not None:\n            feature_importances = self.model.feature_importances_.sort_values(ascending=True)\n            fig = Bar(x=feature_importances, y=feature_importances.index, orientation='h')\n            self.figure_fi = FigureWidget(data=[fig])\n            self.figure_fi.update_layout(\n                autosize=True,\n                margin={\n                    't': 0,\n                    'b': 0,\n                    'l': 0,\n                    'r': 0\n                },\n            )\n            self.figure_fi._config = self.figure_fi._config | {\"displaylogo\": False}\n\n            self.feature_importance_tab.children = [self.figure_fi]\n        else:\n            self.feature_importance_tab.children = []\n\n    def update_pdp_tab(self):\n        if self.pdp_feature_select.v_model not in self.X.columns and self.model is not None:\n            features = list(self.model.feature_importances_.sort_values(ascending=False).index)\n            self.pdp_feature_select.items = features\n            self.pdp_feature_select.v_model = features[0]\n        self.display_pdp()\n\n    def display_pdp(self, *args):\n        if self.model is not None:\n            selected_feature = self.pdp_feature_select.v_model\n            if self.X[self.region.mask][selected_feature].nunique() &gt; 1:\n                predict_func = self.model.__class__.predict\n                figure = PDPIsolate(\n                    df=self.X.copy(), feature=selected_feature, feature_name=selected_feature,\n                    model=self.model, model_features=self.X.columns, pred_func=predict_func,\n                    n_classes=0  # regression\n                ).plot()[0]\n                self.figure_pdp = FigureWidget(figure)\n                self.figure_pdp.update_layout(\n                    autosize=True, width=None, height=None,\n                    margin={\n                        't': 0,\n                        'b': 0,\n                        'l': 0,\n                        'r': 0\n                    },\n                )\n                self.figure_pdp._config = self.figure_pdp._config | {\"displaylogo\": False}\n\n                self.pdp_figure.children = [self.figure_pdp]\n            else:\n                self.pdp_figure.children = ['only one feature value, no pdp to display']\n        else:\n            self.pdp_figure.children = []\n\n    def reset(self):\n        self.model = None\n        self.region = None\n        self.update_feature_importances()\n        self.update_pdp_tab()\n</code></pre>"},{"location":"reference/antakia/gui/tabs/tab1/","title":"tab1","text":""},{"location":"reference/antakia/utils/__init__/","title":"init","text":""},{"location":"reference/antakia/utils/__init__/#antakia.utils.__author__","title":"<code>__author__ = 'AI-vidence'</code>  <code>module-attribute</code>","text":"<p>This is antakia.utils package documentation.</p>"},{"location":"reference/antakia/utils/checks/","title":"checks","text":""},{"location":"reference/antakia/utils/checks/#antakia.utils.checks.is_valid_model","title":"<code>is_valid_model(model)</code>","text":"<p>checks whether the customer model is a valid model</p> Source code in <code>src/antakia/utils/checks.py</code> <pre><code>def is_valid_model(model) -&gt; bool:\n    \"\"\"\n    checks whether the customer model is a valid model\n    \"\"\"\n    return callable(getattr(model, \"score\")) and callable(getattr(model, \"predict\"))\n</code></pre>"},{"location":"reference/antakia/utils/dummy_datasets/","title":"dummy_datasets","text":""},{"location":"reference/antakia/utils/dummy_datasets/#antakia.utils.dummy_datasets.generate_corner_dataset","title":"<code>generate_corner_dataset(num_samples, corner_position='top_right', random_seed=None)</code>","text":"<p>Generate a toy dataset with a corner of the feature space.</p>"},{"location":"reference/antakia/utils/dummy_datasets/#antakia.utils.dummy_datasets.generate_corner_dataset--parameters","title":"Parameters","text":"<p>num_samples : int     Number of samples to generate. corner_position : str, optional     Position of the corner in the feature space, by default \"top_right\"</p>"},{"location":"reference/antakia/utils/dummy_datasets/#antakia.utils.dummy_datasets.generate_corner_dataset--returns","title":"Returns","text":"<p>(np.ndarray, np.ndarray)     Tuple of feature matrix and target vector.</p>"},{"location":"reference/antakia/utils/dummy_datasets/#antakia.utils.dummy_datasets.generate_corner_dataset--raises","title":"Raises","text":"<p>ValueError     If corner_position is not one of \"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\".</p> Source code in <code>src/antakia/utils/dummy_datasets.py</code> <pre><code>def generate_corner_dataset(\n        num_samples: int, corner_position: str = \"top_right\", random_seed: int | None = None\n) -&gt; (np.ndarray, np.ndarray):\n    \"\"\"Generate a toy dataset with a corner of the feature space.\n\n    Parameters\n    ----------\n    num_samples : int\n        Number of samples to generate.\n    corner_position : str, optional\n        Position of the corner in the feature space, by default \"top_right\"\n\n    Returns\n    -------\n    (np.ndarray, np.ndarray)\n        Tuple of feature matrix and target vector.\n\n    Raises\n    ------\n    ValueError\n        If corner_position is not one of \"top_left\", \"top_right\", \"bottom_left\", \"bottom_right\".\n    \"\"\"\n    np.random.seed(random_seed)\n    X = np.random.uniform(0, 1, (num_samples, 2))\n\n    if corner_position == \"top_right\":\n        mask = (X[:, 0] &gt; 0.5) &amp; (X[:, 1] &gt; 0.5)\n    elif corner_position == \"top_left\":\n        mask = (X[:, 0] &lt; 0.5) &amp; (X[:, 1] &gt; 0.5)\n    elif corner_position == \"bottom_right\":\n        mask = (X[:, 0] &gt; 0.5) &amp; (X[:, 1] &lt; 0.5)\n    elif corner_position == \"bottom_left\":\n        mask = (X[:, 0] &lt; 0.5) &amp; (X[:, 1] &lt; 0.5)\n\n    else:\n        raise ValueError(\n            \"Invalid corner position must be one of: top_right, top_left, bottom_right, bottom_left.\"\n        )\n\n    y = mask.astype(int)\n    return X, y\n</code></pre>"},{"location":"reference/antakia/utils/examples/","title":"examples","text":""},{"location":"reference/antakia/utils/examples/#antakia.utils.examples.fetch_dataset","title":"<code>fetch_dataset(example, dataset_name=None)</code>","text":"<p>Fetchs the dataset from our examples/data folder. Called by our examples notebooks.</p>"},{"location":"reference/antakia/utils/examples/#antakia.utils.examples.fetch_dataset--parameters","title":"Parameters","text":"<p>example : str     The name of the example. Must be one of the following: \"california_housing\", \"climate_change_survey\", \"wages\", \"titanic\" dataset_name : str (optional)     The name of the dataset if needed. For example: \"X_train\", \"X_test\", \"y_train\", \"y_test\"</p>"},{"location":"reference/antakia/utils/examples/#antakia.utils.examples.fetch_dataset--returns","title":"Returns","text":"<p>pd.DataFrame     A DataFrame corresponding to the dataset requested of the specified example.</p> Source code in <code>src/antakia/utils/examples.py</code> <pre><code>def fetch_dataset(example: str, dataset_name: str = None) -&gt; pd.DataFrame | dict[str:pd.DataFrame]:\n    \"\"\"\n    Fetchs the dataset from our examples/data folder. Called by our examples notebooks.\n\n    Parameters\n    ----------\n    example : str\n        The name of the example. Must be one of the following: \"california_housing\", \"climate_change_survey\", \"wages\", \"titanic\"\n    dataset_name : str (optional)\n        The name of the dataset if needed. For example: \"X_train\", \"X_test\", \"y_train\", \"y_test\"\n\n    Returns \n    -------\n    pd.DataFrame\n        A DataFrame corresponding to the dataset requested of the specified example.\n    \"\"\"\n    if dataset_name:\n        file_name = f'{example}-{dataset_name}.csv'\n    elif AVAILABLE_EXAMPLES[example]:\n        datasets = {}\n        for name in AVAILABLE_EXAMPLES[example]:\n            datasets[name] = fetch_dataset(example, name)\n        return datasets\n    else:\n        file_name = f'{example}.csv'\n    example_folder = files(\"antakia\").joinpath(\"assets/examples/\")\n    location = str(example_folder.joinpath(f\"{file_name}\"))\n    if os.path.exists(location):\n        dataset = pd.read_csv(location)\n        if 'Unnamed: 0' == dataset.columns[0]:\n            dataset = dataset.set_index(dataset.columns[0])\n            dataset.index.name=None\n        return dataset\n    else:\n        if not os.path.exists(example_folder):\n            os.mkdir(example_folder)\n        dataset = _get_remote_dataset(example, dataset_name)\n        dataset.to_csv(location, index=False)\n        if 'Unnamed: 0' == dataset.columns[0]:\n            dataset = dataset.set_index(dataset.columns[0])\n            dataset.index.name = None\n        return dataset\n</code></pre>"},{"location":"reference/antakia/utils/logging/","title":"logging","text":""},{"location":"reference/antakia/utils/logging/#antakia.utils.logging.OutputWidgetHandler","title":"<code>OutputWidgetHandler</code>","text":"<p>             Bases: <code>Handler</code></p> <p>Custom logging handler sending logs to an output widget</p> Source code in <code>src/antakia/utils/logging.py</code> <pre><code>class OutputWidgetHandler(Handler):\n    \"\"\"Custom logging handler sending logs to an output widget\"\"\"\n\n    def __init__(self, height: int, *args, **kwargs):\n        super(OutputWidgetHandler, self).__init__(*args, **kwargs)\n        layout = {\"width\": \"100%\", \"height\": str(height) + \"px\", \"border\": \"1px solid black\", \"overflow_y\": \"auto\"}\n        self.out = widgets.Output(layout=layout)\n\n    def emit(self, record):\n        \"\"\"Overload of logging.Handler method\"\"\"\n        formatted_record = self.format(record)\n        new_output = {\n            \"name\": \"stdout\",\n            \"output_type\": \"stream\",\n            \"text\": formatted_record + \"\\n\",\n        }\n        self.out.outputs = (new_output,) + self.out.outputs\n\n    def show_logs(self):\n        \"\"\"Show the logs\"\"\"\n        display(self.out)\n\n    def clear_logs(self):\n        \"\"\"Clear the current logs\"\"\"\n        self.out.clear_output()\n</code></pre>"},{"location":"reference/antakia/utils/logging/#antakia.utils.logging.OutputWidgetHandler.clear_logs","title":"<code>clear_logs()</code>","text":"<p>Clear the current logs</p> Source code in <code>src/antakia/utils/logging.py</code> <pre><code>def clear_logs(self):\n    \"\"\"Clear the current logs\"\"\"\n    self.out.clear_output()\n</code></pre>"},{"location":"reference/antakia/utils/logging/#antakia.utils.logging.OutputWidgetHandler.emit","title":"<code>emit(record)</code>","text":"<p>Overload of logging.Handler method</p> Source code in <code>src/antakia/utils/logging.py</code> <pre><code>def emit(self, record):\n    \"\"\"Overload of logging.Handler method\"\"\"\n    formatted_record = self.format(record)\n    new_output = {\n        \"name\": \"stdout\",\n        \"output_type\": \"stream\",\n        \"text\": formatted_record + \"\\n\",\n    }\n    self.out.outputs = (new_output,) + self.out.outputs\n</code></pre>"},{"location":"reference/antakia/utils/logging/#antakia.utils.logging.OutputWidgetHandler.show_logs","title":"<code>show_logs()</code>","text":"<p>Show the logs</p> Source code in <code>src/antakia/utils/logging.py</code> <pre><code>def show_logs(self):\n    \"\"\"Show the logs\"\"\"\n    display(self.out)\n</code></pre>"}]}